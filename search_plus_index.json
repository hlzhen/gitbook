{"./":{"url":"./","title":"前言","keywords":"","body":"前言 [!TIP] 个人开发随笔，以及学习笔记。 © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"context-configuration/":{"url":"context-configuration/","title":"环境配置","keywords":"","body":"开发环境配置 [!TIP|style:callout|label:环境相关配置 |iconVisibility:hidden] Java Maven Tomcat 以及其它软件配置 © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"context-configuration/java-configuration/windows-jdk-x64.html":{"url":"context-configuration/java-configuration/windows-jdk-x64.html","title":"Windows","keywords":"","body":"WindowsJDK配置 1. JDK下载 1. 本文基于64位操作系统配置 2. 下载地址 - 官网下载地址：https://www.oracle.com/java/technologies/downloads/ - 阿里云盘地址：https://www.aliyundrive.com/s/AQ1vbedwWu5 提取码: sr45 云盘分享为jdk的原始安装包 2. 安装 1. 点击下载的安装包进行安装 2. 更改jdk的默认安装路径(如下图) 3. 下一步 > 下一步 > 完成安装 3. 环境配置 1. 鼠标右击我的电脑(此电脑) -> 属性 -> 高级系统设置 -> 点击环境变量 2. 新建系统变量 变量名：JAVA_HOME 变量值：F:\\LocalAppFiles\\java\\jdk1.8.0_151(JDK的安装目录) 3. 新建系统变量 变量名：CLASSPATH 变量值：.;%JAVA_HOME%libdt.jar;%JAVA_HOME%libtools.jar 4. 编辑系统变量Path 新增 -> %JAVA_HOME%\\bin 新增 -> %JAVA_HOME%\\jre\\bin 4. 测试 1. 命令行输入 java || javac 如出现一大堆信息则表示配置成功 © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"context-configuration/java-configuration/macos-jdk.html":{"url":"context-configuration/java-configuration/macos-jdk.html","title":"MacOS","keywords":"","body":"MacOS JDK安装 1. 下载JDK 1. Intel下载地址：https://www.oracle.com/java/technologies/downloads/ 2. M1下载地址：https://www.azul.com/downloads/?package=jdk 3. 选择对应版本下载安装 2. 配置环境 1. 打开终端 输入 open ~/.bash_profile 2. 添加配置信息(注意修改自己的安装地址) export JAVA_HOME=/Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home export PATH=$JAVA_HOME/bin:$PATH:. export CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:. 3. 保存后刷新 source ~/.bash_profile © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"context-configuration/java-configuration/linux-jdk.html":{"url":"context-configuration/java-configuration/linux-jdk.html","title":"Linux","keywords":"","body":"Linux JDK 安装 1. 下载安装 1. 安装前需先检查是否有自带jdk,如有先删除在继续安装 - 检查是否已经存在java相关命令 rpm -qa|grep java rpm -qa|grep jdk rpm -qa|grep gcj - 如果需要卸载 rpm -qa | grep java | xargs rpm -e --nodeps 2. 下载地址：https://www.oracle.com/java/technologies/downloads/ 3. 在/usr/local/目录下新建文件夹java 4. 把下载的安装包上传到/usr/local/java/ 5. 解压 tar -zxvf jdk-8u291-linux-x64.tar.gz 2. 配置环境 1. 编辑配置文件 vim /etc/profile 2. 在末尾追加 export JAVA_HOME=/usr/local/java/jdk1.8.0_291 export JRE_HOME=/usr/local/java/jdk1.8.0_291/jre export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$PATH 3. 使配置文件生效 source /etc/profile 3. 测试 1. 测试javac命令 javac 2. 测试java java 3. 测试版本号 java -version 版本号返回如下 java version \"1.8.0_291\" Java(TM) SE Runtime Environment (build 1.8.0_291-b10) Java HotSpot(TM) 64-Bit Server VM (build 25.291-b10, mixed mode) 4. 查询JAVA_HOME echo $JAVA_HOME 返回 /usr/local/java/jdk1.8.0_291 © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"design-mode/":{"url":"design-mode/","title":"设计模式","keywords":"","body":"设计模式相关 © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"design-mode/设计模式-七大原则.html":{"url":"design-mode/设计模式-七大原则.html","title":"七大原则","keywords":"","body":"测试右侧悬浮目录-1 测试右侧悬浮目录-2 测试右侧悬浮目录-3 [!TIP|style:callout|label:flexible-alerts 插件|iconVisibility:hidden] GitBook高级格式显示的提示块 [NOTE、TIP、WARNING、DANGER] 四种级别 [!TIP|style:callout|label:expandable-chapters-small 插件|iconVisibility:hidden] 左侧菜单的收缩与展开 [!TIP|style:callout|label:code 插件|iconVisibility:hidden] 为代码块提供复制按钮 console.log('test code plugin') [!TIP|style:callout|label:gitHub 插件|iconVisibility:hidden] 为右上角添加github图标 [!TIP|style:callout|label:tbfed-pagefooter 插件|iconVisibility:hidden] 页脚插件 [!TIP|style:callout|label:back-to-top-button 插件|iconVisibility:hidden] 返回顶部插件 [!TIP|style:callout|label:hide-element 插件|iconVisibility:hidden] 隐藏页面元素，例如原始左侧gitbook链接 \"hide-element\": { \"elements\": [\".gitbook-link\"] }, [!TIP|style:callout|label:pageview-count 插件|iconVisibility:hidden] 阅读量插件 [!TIP|style:callout|label:insert-logo 插件|iconVisibility:hidden] // logo插件 为左上角添加logo \"insert-logo\": { \"url\": \"https://ploerp.oss-cn-guangzhou.aliyuncs.com/assets/facebook.png?versionId=CAEQExiBgMCtqai4.xciIDQ1NDA0YjU3Mzc1MzRhZThiNTdmYjVhMmI1M2NjYTRh\", \"style\": \"background: none;max-height:80px;min-height:30px;width:100%\" } [!TIP|style:callout|label:code-optimize 插件|iconVisibility:hidden] code-optimize代码复制插件 [!TIP|style:callout|label:sidebar-style 插件|iconVisibility:hidden] sidebar-style为左侧菜单添加标题与作者信息，在左侧导航最下方替换掉 Published by GitBook 提示信息 //使用方法 { \"plugins\": [\"sidebar-style\"], \"pluginsConfig\": { \"sidebar-style\": { \"title\": \"《Gitbook 文档》\", \"author\": \"温玉\" } } } /* 测试代码复制 */ public void main(String [] args) { System.out.println(\"测试\"); } © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"design-mode/created/":{"url":"design-mode/created/","title":"创建型模式","keywords":"","body":"创建型模式 © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"git-command/":{"url":"git-command/","title":"Git","keywords":"","body":"Git简介 [!TIP] Git是一种源码管理系统（source code management，缩写为SCM）。它对当前文件提供版本管理功能，核心思想是对当前文件建立一个对象数据库（object database），将历史版本信息存放在这个数据库中。 © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"git-command/git常用命令.html":{"url":"git-command/git常用命令.html","title":"常用命令","keywords":"","body":"常用命令大全 前言 [!TIP] 感觉有些命令平时用不上，真当要用的时候又得去各大博客查找，索性就自己根据阮一峰的命令大全进行整理，以后好查找，其它命令用到后会记录到此文当中。 转自: https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html 基本关联流程 # 初始化本地仓库 git init # 添加本地文件 git add . # 提交到本地仓库 git commit -m\"xxx\" # 关联远程 git remote add origin 你的github仓库地址 # 推送到远程 git push origin 分支 多账号配置 # 配置较麻烦，就直接拿简书上大佬的文章了 https://www.jianshu.com/p/3a4b0a1bec13 初始与新建 # 在当前目录新建一个Git代码库 git init # 新建一个目录，将其初始化为Git代码库 git init [project-name] # 下载一个项目和它的整个代码历史 git clone [url] 配置 # 显示当前的Git配置 git config --list # 编辑Git配置文件 git config -e [--global] # 设置提交代码时的用户信息 git config [--global] user.name \"[name]\" git config [--global] user.email \"[email address]\" 添加/删除文件 # 添加指定文件到暂存区 git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 git add [dir] # 添加当前目录的所有文件到暂存区 git add . # 添加每个变化前，都会要求确认, 对于同一个文件的多处变化，可以实现分次提交 git add -p # 删除工作区文件，并且将这次删除放入暂存区 git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 git mv [file-original] [file-renamed] 分支 # 列出所有本地分支 git branch # 列出所有远程分支 git branch -r # 列出所有本地分支和远程分支 git branch -a # 新建一个分支，但依然停留在当前分支 git branch [branch-name] # 新建一个分支，并切换到该分支 git checkout -b [branch] # 新建一个分支，指向指定commit git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 git checkout [branch-name] # 切换到上一个分支 git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 git merge [branch] # 选择一个commit，合并进当前分支 git cherry-pick [commit] # 删除分支 git branch -d [branch-name] # 删除远程分支 git push origin --delete [branch-name] git branch -dr [remote/branch] 标签 # 列出所有tag git tag # 新建一个tag在当前commit git tag [tag] # 新建一个tag在指定commit git tag [tag] [commit] # 删除本地tag git tag -d [tag] # 删除远程tag git push origin :refs/tags/[tagName] # 查看tag信息 git show [tag] # 提交指定tag git push [remote] [tag] # 提交所有tag git push [remote] --tags # 新建一个分支，指向某个tag git checkout -b [branch] [tag] 查看 # 显示有变更的文件 git status # 显示当前分支的版本历史 git log # 显示commit历史，以及每次commit发生变更的文件 git log --stat # 搜索提交历史，根据关键词 git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件 git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 git log --follow [file] git whatchanged [file] # 显示指定文件相关的每一次diff git log -p [file] # 显示过去5次提交 git log -5 --pretty --oneline git log -5 --pretty=oneline # 显示所有提交过的用户，按提交次数排序 git shortlog -sn # 显示指定文件是什么人在什么时间修改过 git blame [file] # 显示暂存区和工作区的差异 git diff # 显示暂存区和上一个commit的差异 git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 git diff HEAD # 显示两次提交之间的差异 git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 git diff --shortstat \"@{0 day ago}\" # 显示某次提交的元数据和内容变化 git show [commit] # 显示某次提交发生变化的文件 git show --name-only [commit] # 显示某次提交时，某个文件的内容 git show [commit]:[filename] # 显示当前分支的最近几次提交 git reflog 远程同步 # 下载远程仓库的所有变动 git fetch [remote] # 显示所有远程仓库 git remote -v # 显示某个远程仓库的信息 git remote show [remote] # 增加一个新的远程仓库，并命名 git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 git pull [remote] [branch] # 上传本地指定分支到远程仓库 git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 git push [remote] --force # 推送所有分支到远程仓库 git push [remote] --all 撤销 # 恢复暂存区的指定文件到工作区 git checkout [file] # 恢复某个commit_id的指定文件到暂存区和工作区 git checkout [commit_id] [file] # 恢复暂存区的所有文件到工作区 git checkout . # 重置暂存区的指定文件，与上一次commit_id保持一致，但工作区不变 git reset [file] # 重置暂存区与工作区，与上一次commit_id保持一致 git reset --hard # 重置当前分支的指针为指定commit_id，同时重置暂存区，但工作区不变 git reset [commit_id] # 重置当前分支的HEAD为指定commit_id，同时重置暂存区和工作区，与指定commit_id一致 git reset --hard [commit_id] # 重置当前HEAD为指定commit_id，但保持暂存区和工作区不变 git reset --keep [commit_id] # 新建一个commit_id，用来撤销指定commit_id # 后者的所有变化都将被前者抵消，并且应用到当前分支 git revert [commit_id] # 暂时将未提交的变化移除，稍后再移入 git stash git stash pop [!TIP|style:callout|label:注意 |iconVisibility:hidden] 撤回应结合历史提交记录，应先查看历史提交记录，通过历史提交记录ID来确定应撤回哪个版本 # 查看历史提交记录，如历史提交记录过多可进行指定条数 --5代表最近5条 git log --pretty=oneline git log -5 --pretty=oneline # 撤回 [commit_id]为查询的提交记录id git revert [commit_id] © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"spring/":{"url":"spring/","title":"Spring5","keywords":"","body":"Spring简介 [!TIP|style:callout|label:Spring概述 |iconVisibility:hidden] Spring是一个轻量级的开源的JavaEE框架，为了解决企业应用开发的复杂性而创建的。 Spring可以将简单的组件配置、组合成为复杂的应用，在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。 IOC(控制反转)，把对象的创建交给Spring管理 AOP(面向切面)，不修改源代码的情况下对功能进行增强 [!TIP|style:callout|label:Spring的形成 |iconVisibility:hidden] Spring的形成，最初来自Rod Jahnson所著的一本很有影响力的书籍《Expert One-on-One J2EE Design and Development》，就是在这本书中第一次出现了Spring的一些核心思想，该书出版于2002年。另外一本书《Expert One-on-One J2EE Development without EJB》，更进一步阐述了在不使用EJB开发JAVA EE企业级应用的一些设计思想和具体的做法 [!TIP|style:callout|label:EJB(Enterprise Java Bean)的问题 |iconVisibility:hidden] 运行环境苛刻 代码移植性差 重量级框架 [!TIP|style:callout|label:Spring框架的特点 |iconVisibility:hidden] 方便解耦，简化开发 通过Spring提供的IOC容器，我们可以将对象之间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。有了Spring,用户不必再为单实例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。 AoP编程 通过Spring提供的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。 声明式事物 在Spring中，可以从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，从而提高开发效率和质量。 对其它框架的集成更加方便 Spring不排斥各种优秀的开源框架，相反Spring可以降低各种框架的使用难度，Spring提供了对各种优秀框架（如Struts,Hibernate、Hessian、Quartz)等的直接支持。 [!TIP|style:callout|label:Spring核心架构图 |iconVisibility:hidden] © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"spring/spring-引言.html":{"url":"spring/spring-引言.html","title":"第一章 引言","keywords":"","body":"引言 1. EJB(Enterprise Java Bean)存在的问题 1. 运行环境苛刻，运行环境变化代码也需要相应调整 2. 代码移植性差 3. 重量级框架 如下图 2. 什么是Spring 1. Spring是一个轻量级的JavaEE解决方案，整合了众多优秀的设计模式。 2.1. 为什么说是轻量级？ 1. 对运行环境没有额外要求，不仅可运行在开源web服务器中，如tomcat、resion、jetty，对收费的也支持，如weblogic、websphere 2. 代码移植性高，不需要实现额外的接口，通过上图可看出↑ 2.2. 为什么可以称之为JavaEE解决方案？ 2.3. 为什么能够做到轻量级，能够成为一个完整的解决方案？ 通过Spring源码可看出，Spring是对原有设计模式的高度封装整合，内部包含工厂、代理、策略、模版等设计模式的合理封装。 3. 设计模式概念 1. 广义概念 面向对象设计中，解决特定问题的经典代码，可以认为只要是一些经典的代码都可以称之为设计模式 2. 狭义概念 GOF4人帮所定义的23种设计模式，例如：工厂、单例、适配器，装饰器、门面、代理、模版等等 4. 工厂设计模式 4.1 什么是工厂设计模式 1. 概念：通过工厂类来创建对象 原始的对象创建则直通过关键字new来声明，例如： User user = new User(); UserDAO userDAO = new UserDAOImpl(); 在工厂设计模式当中，并不提倡这种直接new的方式来创建对象，而是通过一个第三方的工厂类来创建。例如： User user = BeanFactory.getBean(\"xxx\"); UserDAO userDAO = BeanFactory.getBean(\"xxx\"); 那么此时问题就来了，直接new不好吗？为什么还需要通过工厂类来创建？这样不是更加麻烦？ 2. 针对上述问题就引出了工厂类的好处 解耦合，降低耦合 3. 什么是耦合？ 耦合指的是代码间的强关联关系，一方的改变会影响到另一方，不利于代码的维护。 如上述通过new直接创建对象，假如有一天业务逻辑需求发生改变，需要换个类进行引用，那就需要 修改源代码进行调整(不符合开闭原则)。那工厂则可直接通过配置进行调整，不需要进行源代码的修改， 只需要新增业务类然后进行配置即可(符合开闭原则)。耦合关系如下图 4.2 简单工厂的设计 package com.design.gof.created.factory.method.demo3; import java.io.IOException; import java.io.InputStream; import java.util.Properties; /** * 通过简单工厂将代码耦合转移到配置文件中 * Created by Ale on 2022/3/14 */ public class BeanFactory { private static Properties env = new Properties(); static { InputStream inputStream = null; try { /** * 1、通过当前对象流读取 properties 中配置信息 * properties 配置如下 * userService = com.design.gof.created.factory.method.demo3.UserServiceImpl */ inputStream = BeanFactory.class.getResourceAsStream(\"/applicationContext.properties\"); /** * 2、把流加载到Properties集合当中 */ env.load(inputStream); } catch (IOException e) { e.printStackTrace(); } finally { try { if (null != inputStream) { inputStream.close(); } } catch (IOException e) { e.printStackTrace(); } } } /** * 对象的创建方式 * 1.传统的创建方式直接调用构造方法进行创建， * 例如：UserService userService = new UserServiceImpl(); * 2.通过反射的形式来创建对象，可解决耦合 * Class clazz = Class.forName(\"com.xxx.xxx.xxx.某个类\"); * UserService userService = (UserService) clazz.newInstance(); * @return */ public static UserService getUserService() { UserService userService = null; try { Class clazz = Class.forName(env.getProperty(\"userService\")); userService = (UserService) clazz.newInstance(); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } return userService; } } package com.design.gof.created.factory.method.demo3; /** * Created by Ale on 2022/3/14 */ public class User { private String username; private String password; public User() { } public User(String username, String password) { this.username = username; this.password = password; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } package com.design.gof.created.factory.method.demo3; /** * Created by Ale on 2022/3/14 */ public interface UserService { void register(User user); void login(String username, String password); } package com.design.gof.created.factory.method.demo3; /** * Created by Ale on 2022/3/14 */ public class UserServiceImpl implements UserService { private UserDAO userDAO = new UserDAOImpl(); @Override public void register(User user) { userDAO.save(user); } @Override public void login(String username, String password) { userDAO.findByUsernameAndPassword(username, password); } } package com.design.gof.created.factory.method.demo3; /** * Created by Ale on 2022/3/14 */ public interface UserDAO { void save(User user); void findByUsernameAndPassword(String username, String password); } package com.design.gof.created.factory.method.demo3; /** * Created by Ale on 2022/3/14 */ public class UserDAOImpl implements UserDAO { @Override public void save(User user) { System.out.println(\"save user\"); } @Override public void findByUsernameAndPassword(String username, String password) { System.out.println(\"query user by username and password\"); } } package com.design.gof.created.factory.method.demo3; /** * Created by Ale on 2022/3/14 */ public class Client { public static void main(String[] args) { /** * 传统业务调用 */ // UserService userService = new UserServiceImpl(); UserService userService = BeanFactory.getUserService(); User user = new User(\"admin\", \"1234\"); userService.register(user); userService.login(\"admin\", \"1234\"); } } 4.3 通用工厂的设计 简单工厂的问题会导致大量代码的冗余，也不符合开闭原则的设计，例如上述代码中的工厂类，需要进一步进行调整，调整如下 public static Object getBean(String key) { Object ret = null; try { Class clazz = Class.forName(env.getProperty(key)); ret = clazz.newInstance(); } catch (Exception e) { e.printStackTrace(); } return ret; } © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"spring/spring-注入.html":{"url":"spring/spring-注入.html","title":"第二章 注入","keywords":"","body":"注入(Injection) 1. 什么是注入 通过Spring工厂及配置文件，为所创建对象的成员变量赋值 1.1. 为什么需要注入 /** * 原因: 通过编码的方式为成员变量赋值存在耦合，如下代码 * 测试注入 */ @Test public void testInjection() { ApplicationContext context = new ClassPathXmlApplicationContext(\"/applicationContext.xml\"); Person person = (Person) context.getBean(\"person\"); person.setName(\"Ale\"); person.setAge(18); } 1.2. 通过配置文件注入 1. 类的成员变量提供get set方法 2. 配置Spring的配置文件 property -> name:代表当前配置类的成员变量名称 value:代表需要赋值的数据 10 Dream 3. 缩写版 4. 好处以及适用场景 - 好处: 解耦合 - 适用场景: 例如数据库的配置以及各中间件的配置 2. Spring注入的原理分析(应用级简易版分析) Spring底层会通过配置文件的配置信息调用对应类的set方法来完成成员变量的赋值，这种方式也称之为set注入 © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"spring/spring-set注入.html":{"url":"spring/spring-set注入.html","title":"1 Set注入详解","keywords":"","body":"Set注入详解 1. 注入的类型 针对不同类型的成员变量，在标签当中需要嵌套其它标签。 2. JDK内置类型的注入方式 2.1 String + 8种基本数据类型 直接在标签中使用xxx即可 2.2 数组 1. property中嵌套list，list中继续嵌套value 每个value就相当于一个数组的元素 xxxx@163.com xxxxn@163.com 2.3 Set集合 1. 如value值重复的话根据set集合的特性，那么最终会把重复的值给去除掉 1111 1111 2.4 List集合 1. list集合与数组使用的注入方式一致，因为list底层也是数组 xxxx@163.com xxxxn@163.com 2.5 Map集合 ssss 1111 2.6 Properties Properties类型是一个特殊的map, key的类型是String value的类型也是String value1 value2 2.7 复杂的JDK类型(Date) 需要自定义的类型转换器进行处理 3. 自定义类型注入 3.1 方式一 1. 为成员变量提供set get方法 2. 配置文件中进行注入 3.2 方式二 1. 第一种赋值方式存在的问题 - 配置文件代码冗余，如多个service需要配置多个userDao 4. 基于命名空间注入 © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"spring/spring-构造注入.html":{"url":"spring/spring-构造注入.html","title":"2 构造注入","keywords":"","body":"Spring构造注入 1. 回顾注入 1. 什么是注入？ - 通过Spring的配置文件，为成员变量赋值 2. 什么是Set注入？ - Spring调用Set方法，通过配置文件为成员变量赋值 2. 构造注入 1. Spring调用构造方法通过配置文件为成员变量赋值 3. Spring注入总结 © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"spring/spring-控制反转与依赖注入.html":{"url":"spring/spring-控制反转与依赖注入.html","title":"第三章 控制反转 与 依赖注入","keywords":"","body":"Spring控制反转(IOC)与依赖注入(DI) 1. 控制反转(IOC Inverse of Control) 控制：对于成员变量赋值的控制权 控制反转：把对于成员变量赋值的控制权，从代码中反转(转移)到Spring工厂和配置文件中完成 好处：解耦合，提高代码健壮性与可拓展性 底层实现：工厂设计模式 直观体现如下图 2. 依赖注入(Dependency Injection 简称DI) 1. 注入: 通过Spring的配置文件，为对象(bean,组件)的成员变量赋值 2. 依赖注入：当一个类需要另一个类时，就意味着依赖，一旦出现依赖，就可以把另一个类作为本类的成员变量，最终通过Springi配置文件进行注入（赋值） 3. 复杂对象的创建方式 3.1 方式一 FactoryBean接口 /** * 1 实现FactoryBean接口 * Created by Ale on 2022/3/18 */ public class ConnectionFactory implements FactoryBean { private String driverClassName; private String url; private String username; private String password; @Override public Connection getObject() throws Exception { Class.forName(driverClassName); Connection connection = DriverManager.getConnection(url, username, password); return connection; } @Override public Class getObjectType() { return Connection.class; } @Override public boolean isSingleton() { return false; } public void setDriverClassName(String driverClassName) { this.driverClassName = driverClassName; } public void setUrl(String url) { this.url = url; } public void setUsername(String username) { this.username = username; } public void setPassword(String password) { this.password = password; } } /** * 2.配置对应bean信息 * 注意点：FactoryBean接口的实现类，所配置的bean其实是为了创建复杂对象而配置。 * 通过getBean(\"conn\")其实获取的是它所创建的复杂对象Connection * 如果想获取ConnectionFactory对象的话可通过context.getBean(\"&conn\")(\"&\")前缀可获得 */ 3.2 FactoryBean原理(个人理解) 1. 内部流程 - 通过getBean()获得所配置的类的对象，进而通过instanceof判断是否是FactoryBean的实现类 按照接口规范获取getObject()所返回的对象 2. FactoryBean是Sping中用于创建复杂对象的一种方式，也是Spring原生提供的。 3.2 方式二 实例工厂 1. 避免Spring框架的侵入 2. 整合遗留性 3. 栗子 /** * Created by Ale on 2022/3/19 */ public class ConnFactory { public Connection getConnection() { Connection connection = null; try { Class.forName(\"com.mysql.jdbc.Driver\"); connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/plo_admin?useSSL=false\", \"root\", \"root\"); } catch (ClassNotFoundException | SQLException e) { e.printStackTrace(); } return connection; } } 3.3 方式二 静态工厂 public class StaticConnectionFactory { public static Connection getConnection() { Connection connection = null; try { Class.forName(\"com.mysql.jdbc.Driver\"); connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/plo_admin?useSSL=false\", \"root\", \"root\"); } catch (ClassNotFoundException | SQLException e) { e.printStackTrace(); } return connection; } } 4. Spring工厂创建对象总结 © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"spring/spring-scope.html":{"url":"spring/spring-scope.html","title":"第四章 Bean的实例控制","keywords":"","body":"Scope实例控制 1. singleton 1. 单例(默认) 表示无论创建多少次只会存在一个实例 2. 栗子 ApplicationContext context = new ClassPathXmlApplicationContext(\"/applicationContext.xml\"); Account account1 = context.getBean(\"account\", Account.class); Account account2 = context.getBean(\"account\", Account.class); System.out.println(\"account1 = \" + account1); System.out.println(\"account2 = \" + account2); 输出结果 account1 = org.example.spring.scope.Account@48fa0f47 account2 = org.example.spring.scope.Account@48fa0f47 2. prototype 1. 原型 每个实例都是独一无二的 2. 还是上面的栗子 结果输出 account1 = org.example.spring.scope.Account@48fa0f47 account2 = org.example.spring.scope.Account@6ac13091 3. singleton 与 prototype的适用场景 3.1 singleton 1. SqlSessionFactory 2. DAO 3. Service 3.2 prototype 1. Connection 2. SqlSession | Session 3. Struts2 Action © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"spring/spring-bean-lifecycle.html":{"url":"spring/spring-bean-lifecycle.html","title":"第五章 Bean的生命周期","keywords":"","body":"Bean的生命周期 1. 什么是Bean的生命周期 指的是一个对象创建、存活、消亡的一个完整过程 2. 生命周期的三个阶段 2.1 创建阶段 1. 当scope为singleton时，只要工厂创建了，对应的Bean也会创建，随工厂的创建而创建 2. 当scope为prototype时则只有当对应的Bean被获取时才会创建懒加载的策略 3. 如果需要当scope为singleton时Bean的创建为懒加载模式，则在Bean配置中添加lazy-init=\"true\"即可 2.2 初始化阶段 1. Spring工厂创建完对象后，调用对象的初始化方法完成对应的初始化操作 2. 初始化方法的提供：根据业务的需求编写初始化方法，最终完成初始化操作 3. 初始化的操作交由Spring工厂进行调用 # 实现步骤 1. 方式一：实现 InitializingBean接口并实现afterPropertiesSet()方法 2. 方式二：提供一个普通方法myInit()然后配置 # 初始化细节分析 1. 如上两种方式同时存在时，那么优先会执行afterPropertiesSet()其次才是自定义的初始化方法。 2. 注入一定是发生在初始化操作之前。 2.3 销毁阶段 Spring销毁对象前，会调用对象的销毁方法，完成销毁 1. Spring什么时候销毁所创建的对象？ context(工厂对象).close(); 2. 销毁方法是程序猿根据自己的需求去定义，完成销毁操作，交由Spring调用 # 实现步骤 1. 实现 DisposableBean 接口并实现destroy()方法 2. 自定义myDestroy()方法，在配置文件中配置 # 细节分析 1. 销毁方式的操作只适用于scope=\"singleton\" 2. 主要是对资源的释放，例如io,数据库连接 3. 总结 © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"spring/spring-beanPostProcessor.html":{"url":"spring/spring-beanPostProcessor.html","title":"第六章 Bean的后置处理","keywords":"","body":"Bean的后置处理(BeanPostProcessor) 1. 作用 1. BeanPostProcessor：对Spring工厂所创建的对象进行在加工 2. BeanPostProcessor是一个接口，实现后Bean的生命周期也对应进行了一些改变，如下图。 3. 实现BeanPostProcessor接口后，需要实现该接口的两个方法 - 在创建对象并进行注入后，可通过该方法(参数bean由Spring创建的Bean实例，beanName该实例的配置文件ID)进行对应的加工处理，最终返回给Spring - Object postProcessBeforeInitiallization(Object bean String beanName) - 在初始化之后,可通过该方法(参数bean由Spring创建的Bean实例，beanName该实例的配置文件ID)进行对应的加工处理，最终返回给Spring - Object postProcessAfterInitiallization(Object bean String beanName) 4. 如实际项目中用不上Spring Bean的初始化，则没必要区分是Before 还是After，只需实现其中After即可，before则可空实现。 2. 实现 /** * Created by Ale on 2022/3/23 */ public class Category { private Integer id; private String name; public Category() { } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"Category{\" + \"id=\" + id + \", name='\" + name + '\\'' + '}'; } } public class MyBeanPostProcessor implements BeanPostProcessor { @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { return bean; } @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { // Bean的后置处理会为当前工厂所配置每一个对象进行处理 if(bean instanceof Category){ Category category = (Category) bean; category.setName(\"xwb\"); } return bean; } } © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"spring/aop/":{"url":"spring/aop/","title":"第七章 Aop编程","keywords":"","body":" [!TIP|style:callout|label:AOP编程 |iconVisibility:hidden] AOP编程相关笔记 © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"spring/aop/aop-静态代理设计模式.html":{"url":"spring/aop/aop-静态代理设计模式.html","title":"静态代理","keywords":"","body":"静态代理设计模式 1. 栗子 1. 日常生活的栗子： 房东现在有房子需要出租(签合同，收钱)于是房东到处张贴广告引人看房， 一开始房东可能觉得每天这么张贴广告引人看房也还行，可时间久了房东不想继续这样子每天起早贪黑了，于是就不再继续张贴广告引人看房了。 但是这个时候租客就不满意了，广告都没有了没人带我看房了，我怎么找房子？ 对于上述问题矛盾就来了，租客找不到房子，房东也不想继续张贴广告 那么这个时候中介(代理设计模式)就诞生了，看房张贴广告交由中介进行处理， 而房东只需进行合同与钱款的收入，那对于房客来说还是跟之前一样可以看到广告找房子，也有人带看房子。如下图 2. 概念 1. 概念：通过代理类，为原始类(目标类)增加额外的功能 2. 好处：利于(目标类)拓展与维护 3. 名词说明 - 什么是目标类or原始类？ 例如上述案例目标类则是房东，对于开发角度目标类则是业务类(核心功能) - 什么是目标方法or原始方法 上述的案例目标方法则是房东对外租房的方法，对与业务类来说目标方法则是业务方法 - 额外功能(附加功能) 日志，事物，性能 3. 代理开发的核心要素 代理类 = 目标类(原始类) + 额外功能 + 目标类(原始类)实现相同的接口 4. 静态代理编码 // 目标类(原始类) public interface OrderService { void showOrder(); } // 代理类 public class OrderServiceProxy implements OrderService { private OrderServiceImpl orderServiceImpl = new OrderServiceImpl(); @Override public void showOrder() { System.out.println(\"OrderServiceProxy.showOrder -> log\"); orderServiceImpl.showOrder(); } } 5. 静态代理总结 1. 有多少目标类就要有多少代理类，开销大，后续维护管理困难 © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"spring/aop/aop-动态代理设计模式.html":{"url":"spring/aop/aop-动态代理设计模式.html","title":"动态代理","keywords":"","body":"Spring AOP 动态代理 1. 概念 1. 动态代理与静态代理的核心思想都在代理上面，核心目的都是对目标类(原始类)的一种增强，只是实现的方式略有差异。 而动态代理是对静态代理的一种加强，是为了解决静态代理的缺点而衍生的，其本质还是通过代理类对原始类增加额外功能。 2. 编码实现 2.1 环境搭建 org.springframework spring-context 5.2.6.RELEASE org.springframework spring-aop 5.2.6.RELEASE org.aspectj aspectjrt 1.9.5 org.aspectj aspectjweaver 1.9.5 2.2 创建原始对象 /** * 原始类(目标类) * Created by Ale on 2022/3/23 */ public class UserServiceImpl implements UserService { @Override public boolean login(String username, String password) { // 目标方法 System.out.println(\"UserServiceImpl.login, username:\" + username); return true; } @Override public void register(User user) { // 目标方法 System.out.println(\"UserServiceImpl.register user:\" + user); } } 2.3 额外功能(MethodBeforeAdvice接口) /** * 运行在目标方法之前的额外功能 * Created by Ale on 2022/3/24 */ public class MyBeforeAdvice implements MethodBeforeAdvice { @Override public void before(Method method, Object[] objects, Object o) throws Throwable { System.out.println(\"MyBeforeAdvice.before\"); } } 2.4 定义切入点 切入点：额外功能增加的具体位置 目的：具体需要把额外功能加入到哪个目标方法中或者说所有目标方法都增加 2.5 整合切入点与额外功能 2.6 测试 //创建工厂对象 ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"/applicationContext5.xml\"); //如何获取代理对象？ spring工厂通过原始对象的id值获取的就是代理对象，获取的代理对象可通过原始对象的接口类型声明 UserService userService = (UserService) context.getBean(\"userService\"); userService.login(\"xxh\", \"123456\"); 2.7 分析 1. Spring动态的代理类在那里？ - Spring框架运行时，通过动态字节码技术，在JVM内创建的运行在JVM内，程序结束后随着JVM一起消失 2. 什么叫动态字节码技术？ - 通过第三方字节码技术框架，在JVM中创建对应类的字节码进而创建对象。 3. 动态字节码技术的框架 - ASM - Javassist - Cglib - 动态代理相比静态代理是不需要定义代理类文件，都是由JVM运行过程中动态创建的，所以跟静态代理一样，代理类文件过多影响项目管理。 - 动态代理简化代理开发 - 动态代理维护性大大增强 3. 动态代理详解 3.1 MethodBeforeAdvice接口 1. 接口方法: - void before(Method method, Object[] args, @Nullable Object target) throws Throwable - 在...之前执行 2. 参数解释： - method 目标(原始类)方法 - args 目标(原始类)方法参数 - target 目标类(原始类) 3.2 MethodInterceptor接口 1. MethodInterceptor接口 可以根据需要运行在目标方法执行前、后、前后 /** * Created by Ale on 2022/3/26 */ public class Around implements MethodInterceptor { /* invoke方法的作用：额外功能书写在invoke 额外功能 原始方法之前 原始方法之后 原始方法执行之前之后 确定：原始方法怎么运行 参数：MethodInvocation (Method):额外功能所增加给的那个原始方法 返回值：Object:原始方法的返回值 ，如需影响目标方法返回值则不要直接返回目标方法运行结果(前提是要与目标方法返回值类型相等) 例如，直接返回false */ @Override public Object invoke(MethodInvocation invocation) throws Throwable { // 运行在目标方法之前 System.out.println(\"----- before ------\"); Object proceed = invocation.proceed(); return false; } @Override public Object invoke(MethodInvocation invocation) throws Throwable { // 运行在目标方法之后 Object proceed = invocation.proceed(); System.out.println(\"----- after ------\"); return proceed; } @Override public Object invoke(MethodInvocation invocation) throws Throwable { // 运行在目标方法前后 System.out.println(\"----- before ------\"); Object proceed = invocation.proceed(); System.out.println(\"----- after ------\"); return proceed; } @Override public Object invoke(MethodInvocation invocation) throws Throwable { Object proceed = null; try { System.out.println(\"----- before ------\"); proceed = invocation.proceed(); System.out.println(\"----- after ------\"); } catch (Throwable e) { System.out.println(\"----- exception -------\"); e.printStackTrace(); } finally { System.out.println(\"------ finally ------\"); } return proceed; } } --> 4. 切入点详解 execution(* *(..)) 代表所有方法 execution() 代表切入点函数 * *(..) 代表切入点表达式 4.1 方法切入点表达式 1. 对方法无要求 切入点表达式 * *(.. ) * ---> 第一个*代表方法修饰符，返回值 * ---> 第二个*代表方法名 ()---> 参数表 .. ---> 对于参数没要求(参数有或者没有，参数有多少、参数类型是什么都可以) 2. 针对某个方法进行切入且对修饰符、返回值、参数无要求 * xxx(..) 3. 针对某个方法且方法参数有两个类型为String的方法切入 * xxx(String,String) 注意： - 如需针对自定义类型则需要此类型的全类名(xxx.xxx.xxx.User) 例如：* register(org.example.spring.User) - 针对第一个参数有明确要求且后续参数无要求的 * xxx(String,..) 可匹配xxx(String),xxx(String,String),xxx(String,User),xxx(String,User,int) 4. 精准切入表达式 修饰符、返回值 包.类.方法(参数表) * xx.xxx.UserServiceImpl.login(..) * xx.xxx.UserServiceImpl.login(String,String) 4.2 类切入点表达式 1. 指定特定的类作为切入点，自然该类中的所有方法都会加上对应的额外功能 - 指定包 * xxx.xxx.xxx.UserServiceImpl.*(..) - 不指定包 * *.UserServiceImpl.*(..) 一级包 * *..UserServiceImpl.*(..) 多级包 4.3 包切入点表达式 指定包作为额外功能的加入位置，该包中的所有类所有方法都会加入此额外功能 * xxx.xxx.proxy.*.*(..) 注意：此表达式不能支持proxy的子包 * xxx.xxx.proxy..*.*(..) 表示子包也生效 5. 切入点函数 1. execution()函数 - 用于执行切入点表达式，是最为重要的切入点函数，功能最全。可执行方法，类，包切入点表达式 2. args()函数 - 主要用于方法参数的匹配 - 例如args(String,String) - args(String,String) 与 execution(* xxx(String,String)) 是一致的 3. within()函数 - 主要用于类，包切入点表达式的匹配 - 例如within(*..UserServiceImpl.*(..)) - within(*..UserServiceImpl.*(..)) 与 execution(* *..UserServiceImpl.*(..)) 一致 4. @annotation()函数 - 为具有特殊注解的方法加入额外功能 - @annotation(xxx.xx.Log) 5. 切入点函数的逻辑运算(and,or) ## and与操作 - 匹配方法是login 同时 参数为(String,String) - execution(* login(String,String)) - execution(* login(..)) and args(String,String) - 注意：and 操作不能用于同种类型的切入点函数 ## or或者操作 - 可用于同种类型的切入点函数 - execution(* login(..)) or execution(* register(..)) © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"spring/aop/aop-编程.html":{"url":"spring/aop/aop-编程.html","title":"AOP编程","keywords":"","body":"AOP编程 1. 概念 AOP(Aspect Oriented Programing) 面向切面编程 以切面为基本单位的程序开发，通过切面见的协同，相互调用完成程序的构建 面向切面编程其本质就是Spring的动态代理开发，通过代理类为原始类增加额外功能，利于原始类的维护 什么叫切面呢？ 切面 = 切入点 + 额外功能 OOP(Object oriented Programing) 面向对象编程 以对象为基本单位的程序开发，通过对象间的协同，相互调用完成程序的构建 POP(Producer oriented Programing) 面向过程(方法，函数)编程 以过程为基本单位的程序开发，通过过程间的协同，相互调用完成程序的构建 2. AOP编程的开发步骤 1. 准备原始对象 2. 额外功能(需实现MethodInterceptor) 3. 切入点 4. 组装切面(额外功能+切入点) 3. AOP底层实现原理 3.1 JDk的动态代理 Proxy.newProxyInstance方法详解 JDK代理的创建 /** * JDK创建动态代理 * Created by Ale on 2022/3/26 */ public class TestJDKProxy { public static void main(String[] args) { /** * 1. 创建原始对象 */ UserService userService = new UserServiceImpl(); /** * 2. 额外功能 * 注意：注意如果在JDK1.8之前内部类访问外部成员需要外部成员加上 final 修饰 * final UserService userService = new UserServiceImpl(); */ InvocationHandler handler = new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\"----- before ------\"); Object obj = method.invoke(userService, args); System.out.println(\"----- after ------\"); return obj; } }; /** * 2. 创建动态代理(整合) * 注意： 类加载器可借用其它类，不一定非要本类，不过推荐本类中的类加载器 */ UserService userServiceProxy = (UserService) Proxy.newProxyInstance( TestJDKProxy.class.getClassLoader(), userService.getClass().getInterfaces(), handler ); userServiceProxy.login(\"xxh\", \"123456\"); } } 3.2 Cglib的动态代理 Cglib与JDK的区别Cglib创建动态代理的原理：父子继承关系创建代理类，原始类作为父类，代理类作为子类，这样既可以保证二者方法一致， 同时在代理类中提供新的实现(增加额外功能) Cglib编码实现 /** * Created by Ale on 2022/3/27 */ public class TestCglibProxy { public static void main(String[] args) { /** * 1. 创建原始对象 */ UserService userService = new UserService(); /** * 2. 通过Cglib方式创建动态代理对象 * JDK方式创建 * Proxy.newProxyInstance(classloader,interface,invocationhandler) * Cglib方式创建 * Enhancer.setClassLoader() * Enhancer.setSuperClass() * Enhancer.setCallback() ---> cglib包中的 MethodInterceptor() */ Enhancer enhancer = new Enhancer(); enhancer.setClassLoader(TestCglibProxy.class.getClassLoader()); enhancer.setSuperclass(userService.getClass()); MethodInterceptor interceptor = new MethodInterceptor() { @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { System.out.println(\"--- before ---\"); Object ret = method.invoke(userService, args); System.out.println(\"--- after ---\"); return ret; } }; enhancer.setCallback(interceptor); UserService userServiceProxy = (UserService) enhancer.create(); userServiceProxy.login(\"xxh\", \"123456\"); } } 4. 回看BeanPostProcessor 核心问题，为什么通过ID获取的对象实例是代理对象？ 编码实现 /** * Created by Ale on 2022/3/27 */ public class ProxyBeanPostProcessor implements BeanPostProcessor { @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { return bean; } @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { InvocationHandler handler = new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\"---- before ----\"); Object ret = method.invoke(bean, args); System.out.println(\"---- after ----\"); return ret; } }; return Proxy.newProxyInstance(ProxyBeanPostProcessor.class.getClassLoader(), bean.getClass().getInterfaces(), handler); } } 5. JDK与Cglib创建方式总结 1. JDK动态代理 Proxy.newProxyInstance(classloader,interface,invocationhandler) 通过接口创建代理的实现类 2. Cglib动态代理 Enhancer.create() 通过继承父类创建代理类 © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"spring/aop/aop-基于注解编程.html":{"url":"spring/aop/aop-基于注解编程.html","title":"基于注解的AOP编程","keywords":"","body":"AOP基于注解开发 编码实现 1. 基本套路 原始对象 -> 额外功能 -> 切入点 -> 组装切面 /** * @Aspect 注解表示当前为切面类 * Created by Ale on 2022/3/27 */ @Aspect public class MyAspect { /* 1.额外功能(纯代码版本) public class MyAround implements MethodInterceptor { public Object invoke(MethodInvocation invocation){ Object ret invocation.proceed(); return ret; } } 2.切入点 */ /** * 通过 @Around(\"execution(* login(..))\") 定义切入点 * @param joinPoint * @return */ @Around(\"execution(* login(..))\") public Object around(ProceedingJoinPoint joinPoint) { Object ret = null; try { ret = joinPoint.proceed(); } catch (Throwable throwable) { throwable.printStackTrace(); } return ret; } } 2. 切入点的复用 /** * Created by Ale on 2022/3/27 */ @Aspect public class MyAspect { /** * 切入点复用 */ @Pointcut(\"execution(* login(..))\") public void myPointcut(){} /* 1.额外功能(纯代码版本) public class MyAround implements MethodInterceptor { public Object invoke(MethodInvocation invocation){ Object ret invocation.proceed(); return ret; } } 2.切入点 */ /** * 注解版本 * 通过 @Around(\"execution(* login(..))\") 定义切入点 * @param joinPoint * @return */ @Around(\"myPointcut()\") public Object around(ProceedingJoinPoint joinPoint) { Object ret = null; try { System.out.println(\"--- before ---\"); ret = joinPoint.proceed(); } catch (Throwable throwable) { throwable.printStackTrace(); } return ret; } } 3. 动态代理的切换方式 4. ApplicationContextAware接口 1. ApplicationContextAware是什么？ - 用于获取Spring工厂对象，由于Spring工厂是重量级资源，不应该随处创建， 所以可通过实现ApplicationContextAware接口中的setApplicationContext方法来获取工厂对象 2. 通过ApplicationContextAware接口中的setApplicationContext方法获取的工厂对象有什么用？ - 例如当业务需求越来越复杂，服务内部有可能会相互调用，那么此时如果配置了Aop相关的信息， 那么就需要谨慎使用this调用服务内部方法，因为this指向的是原始类，而不是代理类。 如果使用的是this调用则代理类相关的额外功能添加不了(根据业务需求进行处理到底是this还是通过Spring工厂获取代理对象调用) 4.1 ApplicationContextAware接口的栗子 /** * Created by Ale on 2022/3/27 */ public class UserServiceImpl implements UserService, ApplicationContextAware { private ApplicationContext context; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { this.context = applicationContext; } @Override public void login(String username, String password) { System.out.println(\"UserServiceImpl.login\"); } @Override public void register(User user) { /** * 案例：此时我通过AOP为当前类的login方法添加了日志的功能 * 如果在本类中使用this调用login那么日志功能是无效的，因为this指向的是当前原始类而不是代理类 * 解决方法就是实现ApplicationContextAware接口，然后实现setApplicationContext继而得到工厂对象 * 通过工厂对象去获取当前类的代理对象，在通过代理对象调用login方法日志才有效 */ UserService userService = (UserService) this.context.getBean(\"userService\"); userService.login(\"xhh\", \"123456\"); // this指向的是当前类，如果login方法通过aop添加了额外功能的话(比如日志)那么此时是无效的 this.login(\"admin\", \"123456\"); } } © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"spring/aop/aop-总结.html":{"url":"spring/aop/aop-总结.html","title":"AOP总结","keywords":"","body":"AOP总结 © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"spring/spring-注解详解.html":{"url":"spring/spring-注解详解.html","title":"第八章 Spring注解","keywords":"","body":"Spring-注解详解 1. 基础注解 1. @Component - @Component注解用于标注在类上,被标注的类表示将由Spring管理并创建 - @Component 等同于 2. @Scope - @Scope(\"singleton | prototype\") 注解用于标注在类上 - singleton 是默认属性表示单例 被该注解该属性标注的类会与spring工厂一同创建，无论创建多少次拿到的都是同一个实例 - prototype 表示当前创建的是原型对象，获取时才创建，无论创建多少次都会生成新的实例 - @Scope 与配置文件Scope属性一致 3. @Lazy - @Lazy(懒加载) 注解用于标注在类上，通常与@Scope结合使用 - @Lazy 与配置文件lazy-init属性一致 4. @Autowired - @Autowired 用于成员属性注入，只按照类型进行注入。 - @Autowired 如想按照名称注入，需要结合@Qualifier注解一起使用 5. @Autowired 与 @Resource 的区别 ？ - @Autowired 注解由Spring提供 而 @Resource 是由J2EE提供 - @Autowired只按照类型注入 - @Resource 可根据类型或名称注入 - 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常 - 如果指定了name，则从Spring上下文中查找名称(id)匹配的bean进行装配，找不到则抛出异常 - 如果指定了type，则从Spring上下文中找到类型匹配的唯一bean进行装配，找不到或找到多个，都抛出异常 - 如果既没指定name，也没指定type,则自动按照byName方式进行装配。如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。 6. @PropertySource + @Value - @PropertySource 注解标注在类上，用于指定配置文件的位置，结合@Value进行读取数据 - 例如：@PropertySource(\"classpath:/init.properties\") - @Value 用于标注在类成员变量上，被标注的属性可从配置文件中获取对应数据 - 例如：@Value(\"${user.id}\") 表示从init.properties文件中获取key为user.id的值 7. @ImportResource - 导入对应的配置文件 2. 高级注解 1. @Configuration - @Configuration 注解用于标注在类上，表示该类是一个配置类，本质也是@Component的衍生注解 - 被标注的类可看作成spring的applicationContext.xml文件 - 其类内部可通过其它注解对applicationContext.xml 进行替换，@Configuration可看作applicationContext.xml的代替 - 在使用@Configuration替换applicationContext.xml后对应工厂的创建方式也发生改变 - 替换之前 ApplicationContext ctx = new ClassPathXmlApplicationContext(configLocation:\"/applicationContext.xml\"); - 替换之后 ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class); - ApplicationContext ctx = new AnnotationConfigApplicationContext(\"com.xx.xxx\"); 可通过包扫描创建 - Spring在配置Bean中加入了@Configuration注解后，底层就会通过Cglib的代理方式，来进行对象相关的配置、处理 2. @Bean - @Bean注解在配置bean中进行使用，等同于xml配置文件中的标签 - 与@Component不同的是@bean只能标注在方法上 - 使用@Bean注解的前提是类中必须标注@Configuration - @Bean标注的方法其修饰符必须是public - 返回值则必须为一个指定的类型 - 方法名默认则等同于中的id值，如需更改id值则注解改成@Bean(\"自定义id值\")即可 - 方法体则由自己实现创建对象 - 如需控制对象的创建次数则可结合@Scope注解使用，默认是单实例 - @Bean自定义类型注入 @Bean public UserDAO userDAO() { return new UserDAOImpl(); } @Bean public UserService userService(UserDAO userDAO) { // 通过形参注入 UserServiceImpl userService = new UserServiceImpl(); userService.setUserDAO(userDAO); return userService; } @Bean public UserService userService() { // 调用方法形式注入 UserServiceImpl userService = new UserServiceImpl(); userService.setUserDAO(userDAO()); return userService; } - @Bean JDK类型注入 @Bean(\"u\") public User user1() { User user = new User(); user.setId(10); user.setUsername(\"xxh\"); user.setPassword(\"123\"); return user; } 3. @ComponentScan - @ComponentScan 等同于配置文件中的标签 - 用于扫描相关注解(@Component、@Autowired、@Value等) - @ComponentScan(basePackages=\"com.xxx.scan\") 表示扫描某个包以及子包下的相关注解 - 标签排除方式 - context:exclude-filter 表示排除 - type: assignable 排除特定的类型，不进行扫描 annotation 排除特定的注解，不进行扫描 aspectj 切入点表达式(org.example.annotation.entity..*)，对表达式内的包或类不进行扫描，只支持包或类 regex 正则表达式 对匹配正则的不进行扫描 custom 自定义排除策略 - 多种策略可叠加使用 - - - Java语法 @ComponentScan( basePackages = \"org.example.annotation\", excludeFilters = { @ComponentScan.Filter(type = FilterType.ANNOTATION, value = Service.class) } ) - 标签包含方式 - 语法与排除方式一致 - 需设置 use-default-filters=\"false\" 关闭默认扫描策略 - - Java语法 @ComponentScan( basePackages = \"org.example.annotation\", useDefaultFilters = false, includeFilters = { @ComponentScan.Filter(type = FilterType.ANNOTATION, value = Service.class) } ) 3. 纯注解版AOP开发 3.1 开发步骤 原始对象 创建切面类(额外功能、切入点、组装切面) 开启切面自动代理 3.2 代码实现 /** * 纯注解开发AOP * Created by Ale on 2022/4/1 */ @Configuration @ComponentScan(basePackages = \"org.example.annotation.aop\") @EnableAspectJAutoProxy public class AppConfig { } /** * 切面类 * Created by Ale on 2022/4/1 */ @Aspect @Component public class MyAspect { /** * 切入点 */ @Pointcut(\"execution(* org.example.annotation.aop..*.*(..))\") public void pointcut() { } /** * 额外功能 * @param joinPoint * @return */ @Around(\"pointcut()\") public Object around(ProceedingJoinPoint joinPoint) { Object ret = null; try { System.out.println(\"---- log ----\"); ret = joinPoint.proceed(); } catch (Throwable throwable) { throwable.printStackTrace(); } return ret; } } 3.3 纯注解AOP细节分析 1. 代理方式的切换 JDK | Cglib 默认false JDK @EnableAspectJAutoProxy(proxyTargetClass = true) 表示开启AOP自动代理并切换为Cglib方式 默认false为JDK 2. 在SpringBoot开发中@EnableAspectJAutoProxy 无需在定义了，SpringBoot已经集成并且默认代理方式为Cglib © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"spring/other/":{"url":"spring/other/","title":"第九章 其它","keywords":"","body":" [!TIP|style:callout|label: Spring其它知识点|iconVisibility:hidden] 配置文件参数化 自定义类型转换器 YML的整合与使用 整合Mybatis 整合Struts2 整合SSM(Spring+Struts2+Mybatis) © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"spring/other/spring-配置文件参数化.html":{"url":"spring/other/spring-配置文件参数化.html","title":"配置文件参数化","keywords":"","body":"配置文件参数化 将可变参数转移到.properties文件中 © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"spring/other/spring-自定义类型转换器.html":{"url":"spring/other/spring-自定义类型转换器.html","title":"自定义类型转换","keywords":"","body":"自定义类型转换器 1. 类型转换器 1. 类型转换 - 顾名思义类型转换就是把一个类型转换成另一个类型 - 而类型转换器则是这个转换过程的一种封装 2. 作用 - Spring通过类型转换器把配置文件中字符串数据转换成了对象中成员变量对应的类型，进而完成了注入 2. 自定义类型转换器 实现Converter接口 /** * 自定义的类型转换器 * Created by Ale on 2022/3/22 */ public class MyDateConverter implements Converter { private String pattern; public void setPattern(String pattern) { this.pattern = pattern; } @Override public Date convert(String source) { Date date = null; try { SimpleDateFormat sdf = new SimpleDateFormat(pattern); date = sdf.parse(source); } catch (ParseException e) { e.printStackTrace(); } return date; } } 在Spring配置文件中进行配置 © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"spring/other/spring-整合YML配置文件.html":{"url":"spring/other/spring-整合YML配置文件.html","title":"Spring整合YML配置文件","keywords":"","body":"Spring整合YML配置文件 1. 什么是YML 1. YMl(YAML)是一种新形式的配置文件，比XML更简单，比properties更强大 2. properties配置存在的问题 1. properties表达过于复杂，无法表达数据的内在联系 2. properties无法表达对象 集合类型 3. YML与properties配置区别如下图 3. YML语法简介 3.1 如何创建YML文件 1. 如何创建YML文件 - xxx.yml就代表是一个YML文件 application.yml 3.2 语法 #基本语法 k-v name: xxh password: 99909 #对象属性 product: id: 1 name: 长袖 type: x #集合类型 list: - 1111 - 3111 4. Spring集成YML集成思路的分析 1. 准备YML文件 init.yml name: xxh password: 123 2. 读取yml转换成properties YMLpropertiesFactoryBean.setResource(\"yml配置文件路径\") YMLpropertiesFactoryBean.getObject() --- > Propterties 3. 应用PropertySourcesPlaceholderConfigurer PropertySourcesPlaceholderConfigurer.setProperties(); 4. 在类中使用@Value注解进行属性注入 5. 编码整合 5.1 环境搭建 org.yaml snakeyaml 1.23 5.2 编码 /** * Spring整合YML * Created by Ale on 2022/4/2 */ @Configuration @ComponentScan(\"org.example.annotation.yml\") public class YmlAutoConfiguration { @Bean public PropertySourcesPlaceholderConfigurer placeholderConfigurer(){ YamlPropertiesFactoryBean yamlPropertiesFactoryBean = new YamlPropertiesFactoryBean(); yamlPropertiesFactoryBean.setResources(new ClassPathResource(\"init.yml\")); Properties properties = yamlPropertiesFactoryBean.getObject(); PropertySourcesPlaceholderConfigurer placeholderConfigurer = new PropertySourcesPlaceholderConfigurer(); placeholderConfigurer.setProperties(properties); return placeholderConfigurer; } } 5.3 问题点 1. yml集合问题的处理 list: - 1111 - 2222 - 需要结合SpringEL表达式进行处理，需要把list改成 list: 111,222 在进行分割处理 - @Value(\"#{'${list}'.split(',')}\") 2. 对象类型YML配置问题 - @Value(\"${account.name}\") 如属性比较多的话需要重复书写account 这就造成一定的冗余目前Spring是没法解决的，只能这么写 针对上述两个问题，在SpringBoot的@ConfigurationProperties注解中都得到了解决 © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"spring/other/web/spring-mybatis.html":{"url":"spring/other/web/spring-mybatis.html","title":"Spring整合Mybatis","keywords":"","body":"Spring整合Mybatis 1. 回顾Mybatis开发 mybatis开发步骤 1. 实体对象 2. 实体别名 3. 表 4. DAO接口 5. Mapper映射文件 6. 注册Mapper映射文件 7. 调用MybtaisAPI insert into t_user(username,password) values(#{username},#{password}); public class TestMybatis { public static void main(String[] args) throws IOException { InputStream inputStream = Resources.getResourceAsStream(\"mybatis-config.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sessionFactory.openSession(); UserDAO userDAO = sqlSession.getMapper(UserDAO.class); User user = new User(); user.setUsername(\"xxh\"); user.setPassword(\"123456\"); userDAO.save(user); sqlSession.commit(); } } 2. Spring整合Mybtais思路分析 3. Spring整合Mybatis步骤 3.1 环境搭建 1.8 5.2.6.RELEASE 5.1.47 5.2.13.RELEASE 2.0.6 3.5.6 1.2.6 1.9.5 1.9.5 org.springframework spring-context ${spring-version} org.springframework spring-tx ${spring-version} org.springframework spring-aop ${spring-version} org.aspectj aspectjrt ${aspectjrt-version} org.aspectj aspectjweaver ${aspectjweaver-version} mysql mysql-connector-java ${mysql-connector-version} org.springframework spring-jdbc ${spring-jdbc-version} org.mybatis mybatis-spring ${spring-mybatis-version} org.mybatis mybatis ${mybatis-version} com.alibaba druid ${druid-version} junit junit RELEASE test org.slf4j slf4j-log4j12 1.7.30 log4j log4j 1.2.17 3.2 spring整合mybatis配置文件 classpath:org.example.spring.mapper/*Mapper.xml 3.3 编码调用 /** * 测试spring整合mybatis */ @Test public void test1(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"/applicationContext.xml\"); UserDAO userDAO = (UserDAO) context.getBean(\"userDAO\"); User user = new User(); user.setUsername(\"xiaosna\"); user.setPassword(\"99999\"); userDAO.save(user); } 4. spring的事物处理 4.1 什么是事物 保证业务操作完整性(要么一起成功，要么一起失败)的一种数据库机制 事物的特点 ACID A(Atomic) 原子性: 事务中包含的各项操作必须全部成功执行或者全部不执行。 C(consistent) 一致性: 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态 I(Isolated) 隔离性: 一个事务的执行不与其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。 D(Durability) 持久性: 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失 4.2 各框架间事物控制的区别 - JDBC Connection.setAutoCommit(false); 开启事物并手动控制 Connection.commit(); 提交事物 Connection.rollback(); 事物回滚 - mybatis 自动开启事物 sqlSession.commit(); 提交事物 底层还是对Connection的封装 sqlSession.rollback(); 回滚事物 表面上是针对不同的API进行事物控制，可底层还是Connection 4.3 Spring事物的开发 /** * Created by Ale on 2022/3/28 */ public interface UserService { void save(User user); } /** * Created by Ale on 2022/3/28 */ public class UserServiceImpl implements UserService { private UserDAO userDAO; public UserDAO getUserDAO() { return userDAO; } public void setUserDAO(UserDAO userDAO) { this.userDAO = userDAO; } @Transactional @Override public void save(User user) { userDAO.save(user); } } org.springframework spring-tx ${spring-version} /** * 测试spring事物 */ @Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"/applicationContext.xml\"); UserService userService = (UserService) context.getBean(\"userService\"); User user = new User(); user.setUsername(\"xwb\"); user.setPassword(\"8888\"); userService.save(user); } 5. Spring中如何添加事物属性 @Transactional(isolation = ,propagation = ,readOnly = ,timeout = ,rollbackFor = ,noRollbackFor = ) 6. 事物属性详解 - 隔离属性(isolation) 6.1 隔离属性 1. 脏读 - 一个事务，读取了另一个事务中没有提交的数据。会在本事务中产生数据不一致的问题 - 解决方案 @Transactional(isolation=Isolation.READ_COMMITTED) 2. 不可重复读 - 一个事务中，多次读取相同的数据，但是读取结果不一样。会在本事务中产生数据不一致的问题 - 解决方案 @Transactional(isolation=Isolation.REPEATABLE_READ) - 本质 行锁 3. 幻读 - 一个事务中，多次对整表进行查询统计，但是结果不一样，会在本事务中产生数据不一致的问题 - 解决方案 @Transactional(isolation=Isolation.SERIALIZABLE) - 本质 表锁 并发安全 SERIALIZABLE > REPEATABLE_READ > READ_COMMITTED 运行效率 READ_COMMITTED > REPEATABLE_READ > SERIALIZABLE 6.2 数据库对于隔离属性的支持 隔离属性 MySql Oracle ISOLATION_READ_COMMITTED(读已提交) Y Y IOSLATION_REPEATABLE_READ(可重复读) Y N ISOLATION_SERIALIZABLE(窜行化) Y Y 6.3 默认的隔离属性 spring在不指定隔离属性时默认会使用ISOLATION_DEFAULT，而ISOLATION_DEFAULT 则会调用不同数据库所设置的默认隔离属性 MySql默认隔离属性REPEATABLE_READ Oracle默认隔离属性READ_COMMITTED mysql 查看默认隔离属性 高版本命令 select @@transaction_isolation; 低版本命令 select @@tx_isolation; Oracle 查看默认隔离属性 SELECT s.sid,s.serial#, CASE BITAND(t.flag,POWER(2,28)) WHEN 0 THEN 'READ COMMITTED' ELSE 'SERIALIZABLE' END AS isolation_level FROM v$transaction t JOIN v$session s ON t.addr = s.taddr AND s.sid = sys_context('USERENV','SID'); 7. 事物属性详解 - 传播属性(propagation) 7.1 概念 1. 描述了事物解决嵌套问题的特征 2. 什么叫事物的嵌套？ - 指的是一个大的事物中包含了若干个小事物 3. 如果出现了事物嵌套会出现什么问题？ - 大事物中包含多个小事物，如某个小事物发生异常那么前面已提交的事物就不能进行回滚，那么此时就会造成数据的原子性与一致性问题 4. 如何解决事物嵌套的问题？ - 利用事物传播属性 7.2 传播属性的值及用法 required 是传播属性的默认值 属性值 外部不存在事物 外部存在事物 用法 应用 REQUIRED 开启新的事务 融合到外部事务中 @Transactional(propagation=Propagation.REQUIRED) 增删改操作 SUPPORTS 不开启新的事务 融合到外部事务中 @Transactional(propagation=Propagation.SUPPORTS) 查询方法 REQUIRES_NEW 开启新的事务 挂起外部事务，创建新的事务 @Transactional(propagation=Propagation.REQUIRES_NEW) 日志记录方法 NOT_SUPPORTED 不开启新的事务 挂起外部事务 @Transactional(propagation=Propagation.NOT_SUPPORTED) 及其不常用 NEVER 不开启新的事务 抛出异常 @Transactional(propagation=Propagation.NEVER) 及其不常用 MANDATORY 抛出异常 融合到外部事务中 @Transactional(propagation=Propagation.MANDATORY) 及其不常用 8. 事物属性详解 - 只读属性(readOnly) 针对与只进行查询操作的业务方法，加入只读属性，可提高效率 不过一般来说针对查询的方法都不会去加上事物 9. 事物属性详解 - 超时属性(timeout) 1. 指定了事物等待的最长时间(秒为单位) 当事物访问数据库时，又肯呢个访问的数据被别的事物进行加锁的处理，那么此时本事物就必须进行等待 2. 应用 @Transactional(timeout=2) 表示当前事物等待时间为2秒，超出2秒则抛出异常 3. 超时属性的默认值(-1) 最终由对应的数据库来指定 10. 事物属性详解 - 异常属性 Spring事物处理过程中 默认对于运行时异常和error默认是回滚，其余都是提交，例如RuntimeException则是回滚，而Exception则是提交 rollbackFor={java.lang.Exception,xxx,xxx) noRollbackFor={java.lang.RuntimeException,xxx,xx) @Transactional(rollbackFor={java.lang.Exception.class),noRollbackFor=(java.lang.RuntimeException.class)) 11. 事物属性配置总结 1. 隔离属性 配置默认值即可 2. 传播属性 配置required(默认)增删改 3. 只读属性 配置readOnly false(默认)增删改 4. 超时属性 默认值 5. 异常属性 默认值 增删改操作 @Transactionnal 查询操作 @Transactionnal(propagation=Propagation.SUPPORTS,readOnly=true) 12. 基于标签的事物方式 classpath:mapper/*Mapper.xml 13. Spring纯注解整合Mybtais /** * Spring纯注解整合Mybatis * @ComponentScan(\"org.example.annotation.mybatis\") 指定扫描特定包下的相关注解(@Component、@Value等) * @MapperScan 指定DAO所在包进行扫描 * Created by Ale on 2022/4/1 */ @Configuration @ComponentScan(\"org.example.annotation.mybatis\") @MapperScan(basePackages = \"org.example.annotation.mybatis\") @EnableTransactionManagement public class MybatisConfiguration { /** * 数据源配置 * @return */ @Bean public DataSource dataSource() { /* 配置文件版本 */ DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\"); dataSource.setUrl(\"jdbc:mysql://localhost:3306/huanglz?useSSL=false\"); dataSource.setUsername(\"root\"); dataSource.setPassword(\"root\"); return dataSource; } /*** * SqlSessionFactoryBean * @param dataSource * @return */ @Bean public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource) { /* classpath:mapper/*Mapper.xml */ SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSource); sqlSessionFactoryBean.setTypeAliasesPackage(\"org.example.annotation.entity\"); //sqlSessionFactoryBean.setMapperLocations(new ClassPathResource(\"UserDAOMapper.xml\")); ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); Resource[] resources = new Resource[0]; try { resources = resolver.getResources(\"mapper/*Mapper.xml\"); } catch (IOException e) { e.printStackTrace(); } sqlSessionFactoryBean.setMapperLocations(resources); return sqlSessionFactoryBean; } /** * 事物相关 * @param dataSource * @return */ @Bean public DataSourceTransactionManager dataSourceTransactionManager(DataSource dataSource){ /* 配置文件版本 */ DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager(); dataSourceTransactionManager.setDataSource(dataSource); return dataSourceTransactionManager; } } © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"spring/other/web/spring-struts2.html":{"url":"spring/other/web/spring-struts2.html","title":"Spring整合Struts2","keywords":"","body":"Spring整合Struts2 1. 环境搭建 4.0.0 org.example.web spring5-web 1.0-SNAPSHOT war spring5-web Maven Webapp http://www.example.com UTF-8 1.8 1.8 1.8 2.3.8 5.2.6.RELEASE 1.9.5 1.9.5 javax.servlet javax.servlet-api 3.1.0 provided javax.servlet jstl 1.2 javax.servlet.jsp javax.servlet.jsp-api 2.3.3 provided org.apache.struts struts2-spring-plugin ${struts2-version} org.springframework spring-web ${spring-version} org.springframework spring-core ${spring-version} org.springframework spring-beans ${spring-version} org.springframework spring-context ${spring-version} org.springframework spring-tx ${spring-version} org.springframework spring-aop ${spring-version} org.aspectj aspectjrt ${aspectjrt-version} org.aspectj aspectjweaver ${aspectjweaver-version} org.slf4j slf4j-log4j12 1.7.30 log4j log4j 1.2.17 2. Spring整合MVC(Struts2)框架的核心思路 2.1 准备工厂 1. 工厂的创建方式 - AppicationContext context = new ClassPathXmlAppicationContext(\"/applicationContext.xml\"); 2. 基于Web的创建方式 AppicationContext context = new WebXmlAppicationContext(\"/applicationContext.xml\"); 3. 如何保证工厂唯一性的同时又能被公用 - 工厂是一个重量级资源，那么如果在每一次调用的同时去创建的话会非常消耗内存资源，那结合Web ServletContext作用域的引入就可避免这个工厂被创建多次进而又可达到共用目的 - ServletContext 特点就是只创建一次并且整个应用可通过ServletContext.getAttribute(\"xxxx\")获取对应数据。 那么在ServletContext创建时可通过ServletContextListener监听器监听，只要ServletContext创建就可创建Spring的工厂从而达到唯一性 4. 总结 ServletContextListener(唯一) AppicationContext context = new WebXmlAppicationContext(\"/applicationContext.xml\"); ServletContext.setAttribute(\"xxxx\",context);(共用) 5. ContextLoaderListener - Spring的ContextLoaderListener就是针对上述问题的封装,通过web.xml配置即可 org.springframework.web.context.ContextLoaderListener contextConfigLocation classpath:applicationContext.xml 2.2 配置文件引入 Spring的applicationContext.xml struts2的struts.xml log4j.propertis 2.3 初始化配置 org.springframework.web.context.ContextLoaderListener contextConfigLocation classpath:applicationContext.xml struts2 org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter struts2 /* ###配置根 log4j.rootLogger=debug,console ##日志输出到控制台显示 log4j.appender.console=org.apache.log4j.ConsoleAppender log4j.appender.console.Target=System.out log4j.appender.console.layout=org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n 2.4 服务层开发 public interface UserService { void register(User user); } public class UserServiceImpl implements UserService { @Override public void register(User user) { System.out.println(\"UserServiceImpl.register\"); } } public class RegAction implements Action { private UserService userService; public UserService getUserService() { return userService; } public void setUserService(UserService userService) { this.userService = userService; } @Override public String execute() throws Exception { userService.register(new User()); return Action.SUCCESS; } } /index.jsp 2.5 测试 把应用部署到tomcat中浏览器访问localhost:端口号/reg.action即可 © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"spring/other/web/spring-struts2-mybatis.html":{"url":"spring/other/web/spring-struts2-mybatis.html","title":"Spring-Struts2-Mybatis(配置化整合)","keywords":"","body":"SpringWeb开发 - SSM整合(基于配置文件) 1 创建web工程进行环境搭建 4.0.0 org.example.web spring5-struts2-mybatis 1.0 war spring5-struts2-mybatis Maven Webapp http://www.example.com UTF-8 1.8 1.8 1.8 2.3.8 5.2.6.RELEASE 5.1.47 5.2.13.RELEASE 2.0.6 3.5.6 1.2.6 1.9.5 1.9.5 javax.servlet javax.servlet-api 3.1.0 provided javax.servlet jstl 1.2 javax.servlet.jsp javax.servlet.jsp-api 2.3.3 provided org.apache.struts struts2-spring-plugin ${struts2-version} org.springframework spring-web ${spring-version} org.springframework spring-core ${spring-version} org.springframework spring-beans ${spring-version} org.springframework spring-context ${spring-version} org.springframework spring-tx ${spring-version} org.springframework spring-aop ${spring-version} org.aspectj aspectjrt ${aspectjrt-version} org.aspectj aspectjweaver ${aspectjweaver-version} mysql mysql-connector-java ${mysql-connector-version} org.springframework spring-jdbc ${spring-jdbc-version} org.mybatis mybatis-spring ${spring-mybatis-version} org.mybatis mybatis ${mybatis-version} com.alibaba druid ${druid-version} org.slf4j slf4j-log4j12 1.7.30 log4j log4j 1.2.17 2. 引入配置文件 1. Spring -> applicationContext.xml 2. Struts2 -> struts.xml 3. log4j -> log4j.properties 三个文件在resources文件夹下创建 3. 初始化web.xml配置 Archetype Created Web Application org.springframework.web.context.ContextLoaderListener contextConfigLocation classpath:applicationContext.xml struts2 org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter struts2 /* 4. 整合mybatis 1. 配置文件的配置 1.DataSource 2.SqlSessionFactory ----SqlSessionFactoryBean 1.dataSource 2.typeAliasesPackage 3.mapperLocations 3.MapperScannerConfigur-->DAO接口实现类 2.编码 1.entity 2.table 3.DA0接口 4.实现Mapper文件 5.编写service加入事物 1. 原始对象 2. 额外功能 3. 切入点(@Tranactionnal) 4. 组装切面 classpath:mapper/*Mapper.xml 5. 整合Struts2 1.开发控制器implements Action注入Service 2.Spring的配置文件 1.注入Service 2.scope prototype 3.struts.xml /** * 需要注入此Action * Created by Ale on 2022/3/30 */ public class RegAction implements Action { private UserService userService; private User user; public void setUser(User user) { this.user = user; } public void setUserService(UserService userService) { this.userService = userService; } @Override public String execute() throws Exception { userService.register(user); return Action.SUCCESS; } } /regOk.jsp 5. 配置优化 5.1 分层 通过Spring的多配置处理，可把Action、Service、DAO间的配置进行拆分然后在合并到总配置中，利于管理与维护 Action -----> applicationContext-action.xml Service -----> applicationContext-service.xml DAO -----> applicationContext-dao.xml 5.2 配置方式 1. 通配符方式 1. 非web环境 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"/applicationContext-*.xml\"); 2. web环境 contextConfigLocation classpath:applicationContext-*.xml 2. 标签方法 1. 需要提供一个主配置文件(applicationContext.xml)，该文件主要目的用于整合其它配置文件 6. Spring-Struts2-Mybatis整合项目地址 github地址：https://github.com/hlzhen/code-learn © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-02 14:15:32 "},"spring-source/":{"url":"spring-source/","title":"Spring源码分析","keywords":"","body":"Spring源码分析 [!TIP|style:callout|label:Spring源码分析 |iconVisibility:hidden] TODO 后续继续 [!TIP|style:callout|label:Spring核心架构图 |iconVisibility:hidden] © Ale all right reserved，powered by Gitbook该文修订时间： 2022-05-29 18:48:31 "},"spring-source/源码环境搭建.html":{"url":"spring-source/源码环境搭建.html","title":"第一章 源码环境搭建","keywords":"","body":"Spring5源码环境搭建 1. 获取源码 1. 下载地址：https://github.com/spring-projects/spring-framework 2. 5.x是用gradle(类似maven)进行搭建的其依赖也是，但是仓库还是应用的maven仓，所以可在build.gradle文件中找到repositories标签(150行左右)加入阿里云的maven镜像仓 // 阿里云仓库 maven { url \"https://maven.aliyun.com/repository/spring/\" } maven { url \"https://maven.aliyun.com/repository/public/\" } // 默认配置 maven { url \"https://repo.spring.io/libs-spring-framework-build\" } mavenCentral() 3. 什么是gradle? # Gradle是一个基于JVM的构建工具，是一款通用灵活的构建工具，支持maven， Ivy仓库，支持传递性依赖管理，而不需要远程仓库或者是pom.xml和ivy.xml配置文件，基于Groovy，build脚本使用Groovy编写 2. IDEA中导入Spring源码 [!TIP] 导入后IDEA会自动下载依赖，等待所有依赖下载完成即可 如没有自动下载，可右击项目build © Ale all right reserved，powered by Gitbook该文修订时间： 2022-05-03 11:27:55 "},"spring-source/spring工厂.html":{"url":"spring-source/spring工厂.html","title":"第二章 工厂容器分析","keywords":"","body":"Spring工厂解析 1. 什么是工厂为什么又称之为容器 # 工厂是为了把创建对象与使用进行分离，其工厂模式主要职责就是为了创建对象 # 在spring的工厂中不仅需要创建对象，还需把其创建的对象保存起来进行维护防止重复创建，前提是创建的对象是单实例的(scope=singleton) # 那么既然创建对象需要存储起来则用于存储对象的东西就叫容器(spring中采用Map存储) # Scope(实例控制属性) 取值范围 ## singleton 单例(默认，无论多少次创建只有一个实例) ## prototype 原型(每次创建都会产生新实例) 2. Spring工厂的分类 - BeanFactory(根容器)，定义了工厂的基本能力(getBean、isSingleton、isPrototype、containsBean等等) - HierarchicalBeanFactory 提供了父子容器管理让其具有继承能力(父子容器管理，在SpringMVC中有相应的体现，父子容器相互配合，实际上就是此接口作用) - ConfigurableBeanFactory 可配置工厂，为当前所创建的对象提供单例或多实例、类型转换器、后置处理Bean - SimpleJndiBeanFactory - AutowireCapableBeanFactory 提供了自动注入（autowire属性)以及初始化Bean(InitializingBean)、销毁Bean(DisposableBean)的能力 - ListableBeanFactory 提供了获取相关配置信息的能力(containsBeanDefinition()是否存在某个bean、getBeanDefinitionCount()获取bean的数量、getBeanNamesForType()基于名字获取bean类型等等) - DefaultListableBeanFactory 复合了上面所有bean的能力是一个成熟的工厂 - XMLBeanFactory 使用基于XML配置的信息完成对Bean的创建(XmLBeanDefinitionReader通过此类读取XML的配置信息)，此工厂在Spring3.1版本中已过期 1. 从上可看出ApplicationContext工厂实现了HierarchicalBeanFactory与ListableBeanFactory那么此时的ApplicationContext是一个高级的工厂，具备了多种特性 2. Spring的设计是由一系列的工厂堆砌而成，每个工厂的职责单一，并且最终整合到了ApplicationContext当中 © Ale all right reserved，powered by Gitbook该文修订时间： 2022-05-15 14:40:13 "},"spring-source/spring-xmlfactorybean.html":{"url":"spring-source/spring-xmlfactorybean.html","title":"第三章 XMLBeanFactory分析","keywords":"","body":"XMLFactoryBean的源码剖析 1. XMLFactoryBean的使用 // 通过ClassPathResource读取配置文件，把XML封装成Java对象，进而创建Spring工厂容器 BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(\"applicationContext.xml\")); // 从工厂容器中获取对象 User user = (User) beanFactory.getBean(\"user\"); 2. 问题点 BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(\"applicationContext.xml\")) 1. 怎么读取配置文件 如何获得IO资源？ - ClassPathResource 作为 Resource 的子类提供了获取InputStream流的实现 2. 读取配置文件后，如何在Spring中以对象形式进行封装？通过谁封装成对象？ - 通过 XmlBeanDefinitionReader 把配置文件信息封装成BeanDefinition，BeanDefinition是接口，默认用其实现类GenericBeanDefinition - 所以最终封装成的对象是GenericBeanDefinition 3. 所创建对象的生命周期 © Ale all right reserved，powered by Gitbook该文修订时间： 2022-05-15 16:12:33 "},"springmvc/":{"url":"springmvc/","title":"SpringMVC","keywords":"","body":" [!TIP|style:callout|label:SpringMVC |iconVisibility:hidden] 对SpringMVC的学习记录 TODO 后续继续 © Ale all right reserved，powered by Gitbook该文修订时间： 2022-05-29 18:48:09 "},"springmvc/springmvc-引言.html":{"url":"springmvc/springmvc-引言.html","title":"第一章 引言","keywords":"","body":"SpringMVC 引言 1. 什么是SpringMVC 1. 概念：SpringMVC是基于Spring Framework衍生而来的一个MVC框架。主要解决了原有MVC框架开发过程中，控制器(Controller)的问题 2. MVC是一个架构思想，在JavaEE开发中多用于Web开发 3. 基于MVC架构思想会把一个项目划分为3个层次，M(Model)模型层，V(View)视图层，C(Controller)控制层 View jsp Model Service+DAO Controller Servlet 4. MVC这种分层开发，体现了面向对象各司其职的设计思想，利于项目维护。 2. SpringMVC解决了什么问题？ 2.1 原有MVC控制器是什么？ 1. 原有MVC的控制器技术实现是通过Servlet(基于Java Model2模式)，通过Servlet对请求的处理与响应 2. 控制器的核心作用 1. 接收用户请求 2. 调用业务功能 3. 根据业务处理结果控制程序的运行流程 2.2 控制器的核心代码 1. 接收客户端请求 2. 调用业务对象(Service) 3. 流程跳转(页面跳转) 2.3 Servlet控制器的问题分析 2.3.1 请求参数问题 1. 代码冗余 2. 只能接受字符串类型数据，需要手工转换 3. 无法自动封装对象(可借助第三方框架) 2.3.2 业务对象耦合问题 // 直接new获取业务对象会存在耦合，不利于项目维护 UserService userService = new UserServiceImpl(); boolean isLogin = userService.login(name,password); 2.3.3 流程跳转问题(页面跳转) 1. 跳转路径耦合 2. 与视图层技术耦合 1. 针对上述产生的问题在SpringMVC中得到了更好的解决。换句话说SpringMVC的诞生就是为了解决传统控制器中存在的各种问题。 © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-07 14:11:30 "},"springmvc/springmvc-开发案例.html":{"url":"springmvc/springmvc-开发案例.html","title":"第二章 SpringMV开发案例","keywords":"","body":"SpringMVC开发案例、 1. 开发版本 1. JDK 1.8 2. Maven 3.6 3. IDEA 2021.1 4. SpringFramework 5.2.6 5. Tomcat 8.5.61 6. Mysql 8.0.22 2. 环境搭建 4.0.0 org.example.mvc SpringMVC-Study pom 1.0 mvc-study-01 8 8 1.8 5.2.6.RELEASE 1.9.5 1.9.5 5.1.47 5.2.13.RELEASE 2.0.6 3.5.6 1.2.6 org.springframework spring-web ${spring-version} org.springframework spring-webmvc ${spring-version} org.springframework spring-core ${spring-version} org.springframework spring-beans ${spring-version} org.springframework spring-context ${spring-version} org.springframework spring-tx ${spring-version} org.springframework spring-aop ${spring-version} org.aspectj aspectjrt ${aspectjrt-version} org.aspectj aspectjweaver ${aspectjweaver-version} org.slf4j slf4j-api 1.7.25 org.slf4j jcl-over-slf4j 1.7.25 ch.qos.logback logback-classic 1.2.3 ch.qos.logback logback-core 1.2.3 org.logback-extensions logback-ext-spring 0.1.4 mysql mysql-connector-java ${mysql-connector-version} org.springframework spring-jdbc ${spring-jdbc-version} org.mybatis mybatis-spring ${spring-mybatis-version} org.mybatis mybatis ${mybatis-version} com.alibaba druid ${druid-version} org.yaml snakeyaml 1.23 junit junit 4.13.1 compile 3. 配置文件 1. SpringMVC的配置文件就是Spring的配置文件 2. 配置文件名称可以随意命名(dispatcher.xml) 3. 文件位置可以根据需要随意放置(建议是放置在资源文件夹的根下) 4. 初始化配置 4.1 web.xml配置 1. web.xml中配置DispatcherServlet(前端控制器｜中央控制器) 2. DispatcherServlet的核心作用 1. 用于创建Spring工厂(容器) 2. 控制SpringMVC的内部运行流程 dispatcherServlet org.springframework.web.servlet.DispatcherServlet contextConfigLocation classpath:dispatcher.xml 1 dispatcherServlet / 4.2 SpringMVC配置 1. 配置的主要作用是引入SpringMVC的核心功能 - 主要引入了2个核心类型，如下图 1. RequestMappingHandlerMapping 2. RequestMappingHandlerAdapter 3. RequestMappingHandlerMapping作用 - 实现了HandlerMapping接口，对@RequestMapping注解进行处理，并将其注册到请求映射表中 4. RequestMappingHandlerAdapter作用 - 实现了HandlerAdapter接口，是处理请求的适配器，确定调用某个符合要求的控制器中具体的服务方法 2. 1. 对基本注解进行扫描 - DispatcherServlet所创建的工厂需要读取XML的配置文件，不能使用纯注解的开发。 - 所以目前使用Spring配置文件+基础注解的形式，进行开发。 2. 基础注解 - @Component @Service @Repository @Controller @Scope @Transactional等 3. 高级注解 - @Configuration @Bean @ComponentScan等 5. 编码开发 5.1 SpringMVC与Servlet开发的区别 5.2 开发流程 1. 开发一个类在上面标注@Controller注解(标注@Controller的类称之为控制类) 2. 在标注@Controller注解的类中提供一个方法参数为(HttpServletRequest,HttpServletResponse)， 返回值为String同时在方法上标注@RequestMapping注解定义请求路径 3. 在控制器方法中，完成对应的业务开发，把对应JSP路径作为方法的返回值返回 5.3 控制器编码 /** * Created by Ale on 2022/4/7 */ @Controller public class FirstController { @RequestMapping(\"/first\") public String first(HttpServletRequest request, HttpServletResponse response) { System.out.println(\"first controller\"); return \"/result.jsp\"; } } 5.4 注意 1. SpringMVC开发中习惯性的把Controller称之为控制器，但是SpringMVC内部则是称之为Handler 2. 针对于Servlet开发，一种类型的Servlet只会被Tomcat创建一次，所以Servlet是单实例的，但并不是单例设计模式 3. 对与SpringMVC Controller而言它可被创建多次，也可被创建一次。 1. 默认是只创建一次,会存在线程安全问题，如果想被创建多次可添加注解@Scope(\"prototype\") 4. @RequestMapping注解 - 核心作用是为方法提供外部访问的URL路径 - 路径分隔符\"/\"可省略，如有多级则第一级可省略，如下栗子 - @RequestMapping(\"users\") - @RequestMapping(\"user/orders\") - 如果标注在类上就表示当前控制器中所有对外提供服务的方法就要加上一个层级 - 比如在类中标注@RequestMapping(\"users\")，那么其方法的访问路径就是users/xxx/xxx 5. 一个控制器方法多个访问路径 - @RequestMapping(value = {\"users\",\"user/list\"}),代表当前控制器方法可通过users与user/list两个方法访问 © Ale all right reserved，powered by Gitbook该文修订时间： 2022-04-11 13:48:12 "},"docker/":{"url":"docker/","title":"Docker","keywords":"","body":" [!TIP|style:callout|label:Docker |iconVisibility:hidden] 对Docker的学习记录 TODO 基础篇，高级篇后续跟进 © Ale all right reserved，powered by Gitbook该文修订时间： 2022-05-29 18:47:48 "},"docker/docker-简介.html":{"url":"docker/docker-简介.html","title":"Docker简介及安装","keywords":"","body":"Docker概要 1. 前置知识 - Docker是什么 可以干什么? # 官方文档是这样说的： 1. Docker(基于Go语言开发) 是一个用于开发、发布和运行应用程序的开放平台。 2. Docker 提供了在称为容器的松散隔离环境中打包和运行应用程序的能力。 - 隔离和安全性允许您在给定主机上同时运行多个容器。容器是轻量级的，包含运行应用程序所需的一切，因此您无需依赖主机上当前安装的内容。 - 您可以在工作时轻松共享容器，并确保与您共享的每个人都获得以相同方式工作的同一个容器。 # 上述两点翻译过来也就是说Docker是用于对应用组件的封装、分发、部署、运行等生命周期的管理. # 使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到 \"一次镜像，处处运行\" # Docker的出现解决了运行环境和配置问题的软件容器， 方便做持续集成并有助于整体发布的容器虚拟化技术。 # Docker 本身是一个容器运行载体或称之为管理引擎。我们可以把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是image镜像文件。只有通过这个镜像文件才能生成 Docker容器实例(类似Java中new出来一个对象)。 2. 前置知识 - Docker三要素 1. 镜像(Image) - 就好比类,每一个类都是一个镜像 - Docker 镜像（Image）就是一个只读的模板。 - 镜像可以用来创建 Docker 容器，—个镜像可以创建很多容器(就好比一个类可以创建多个实例)。 2. 容器(Container) - 每一个类的实例就是一个容器 - Docker 利用容器(Container）独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。 - 就像是Java中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。 - 容器为镜像提供了一个标准的和隔离的运行环境，它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台 3. 仓库 - 是集中存放镜像文件的场所。 - 就好比Maven中的仓库一样,区别就是Maven的仓库存放的是各种jar而docker仓库存储的是各种镜像。 # 如下图 3. Docker安装前提条件 # 安装说明以及前提条件: 1. Docker 并非是一个通用的容器工具，它依赖于已存在并运行的 Linux 内核环境。 2. Docker 实质上是在已经运行的 Linux 下制造了一个隔离的文件环境，因此它执行的效率几乎等同于所部署的 Linux 主机。 3. 因此，Docker 必须部署在 Linux 内核的系统上, 如果其他系统想部看 Docker 就必须安装一个虚拟 Linux 环境。 4. 目前, Centos仅发行版本中的内核支持 Docker。 5. Docker 运行在CentOS7(64-bit)上， 要求系统为64位、Linux系统内核版本为3.8以上 # 如何查看linux内核信息? 1. cat /etc/redhat-release 查看linux版本 2. uname -r 3. uname命令用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等） # Docker官网: 1. https://www.docker.com/ 官网地址 2. https://hub.docker.com/ 镜像仓库地址 3. https://docs.docker.com/engine/install/centos/ docker服务端下载地址基于CentOS 4. Docker服务端安装步骤 4.1 确保是ContOS7及以上版本 #可查看版本信息 cat /etc/redhat-release 4.2 卸载旧版本 #查看是否安装过docker rpm -qa | grep docker # 卸载命令 sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 4.3 确保gcc相关环境 #安装gcc yum -y install gcc #gcc-c++ yum -y install gcc-c++ 4.4 安装yum-utils包以及设置仓库 #安装yum-utils包 yum install -y yum-utils #设置镜像裤地址 yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo #https://download.docker.com/linux/centos/docker-ce.repo docker官方地址国内有超时等问题 #http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 阿里云地址 4.5 更新yum软件包索引(可选) yum makecache fast 4.6 安装Docker引擎 #安装最新版本的 Docker Engine、containerd 和 Docker Compose 或进入下一步安装特定版本 yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin 4.7 启动docker #启动docker systemctl start docker #查看版本 docker version #查看docker进程信息 ps -ef|grep docker 4.8 docker hello-world docker run hello-world 4.9 卸载 #停止docker systemctl stop docker #重启docker systemctl restart docker #卸载 Docker Engine、CLI、Containerd 和 Docker Compose 软件包 yum remove docker-ce docker-ce-cli containerd.io #主机上的映像、容器、卷或自定义配置文件不会自动删除。要删除所有映像、容器和卷： rm -rf /var/lib/docker rm -rf /var/lib/containerd © Ale all right reserved，powered by Gitbook该文修订时间： 2022-05-20 13:58:44 "},"docker/docker-aliyun.html":{"url":"docker/docker-aliyun.html","title":"阿里云镜像加速配置","keywords":"","body":"阿里云镜像加速配置 1. 注册或登录阿里云账号 1. 阿里云地址 https://www.aliyun.com/ 2. 登录后选择控制台 3. 点击菜单左侧菜单选择容器镜像服务 2. 配置镜像加速器 #通过修改daemon配置文件/etc/docker/daemon.json来使用加速器 mkdir -p /etc/docker tee /etc/docker/daemon.json © Ale all right reserved，powered by Gitbook该文修订时间： 2022-05-18 14:26:00 "},"docker/docker-image.html":{"url":"docker/docker-image.html","title":"Docker镜像","keywords":"","body":"Docker镜像 1. Docker镜像是什么 [!TIP] docker镜像是一种轻量级、可执行的独立软件包,它包含运行某个软件所需的所有内容, 我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时所需要的库、环境和配置文件等) 这个打包好的运行环境就是一个镜像文件 只有通过这个镜像文件才能生成Docker容器实例(类似Java中new出来一个对象）。 ps: 就是说可以把我们自己开发的应用打包成一个镜像文件 2. UnionFS(联合文件系统） [!TIP] Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统, 它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。 Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各利具体的应用镜像。 特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 3. Docker加载原理 [!TIP] docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统就是UnionFS。 bootis(boot file system)主要包含bootloader和kernel，bootloader主要是引导加载kernel， Linux刚启动时会加载bootfs文件系统，在 Docker镜像的最底层是引导艾件系统bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权己由bootfs转交给内核，此时系统也会卸载bootfs。 rootfs (root file system),在bootfs之上.包含的就是典型 Linux 系统中的 /dev、/proc、/bin、/etc等标准目录和文件.rootfs就是各种不同的操作系统发行版,比如Ubuntu, Centos等等. © Ale all right reserved，powered by Gitbook该文修订时间： 2022-05-20 11:05:22 "},"docker/docker-command.html":{"url":"docker/docker-command.html","title":"Docker基本命令","keywords":"","body":"Docker基础命令 1. 帮助启动类命令 #启动docker systemctl start docker #停止docker systemctl stop docker #重启docker systemctl restart docker #查看docker状态 systemctl status docker #开机启动 systemctl enable docker #查看docker概要信息 docker info #查看docker总体帮助文档 docker --help #查看docker命令 docker 2. 镜像命令 #查看镜像列表 docker images -a(所有镜像) -q(只显示镜像id) #查询镜像 --limit 5(表示只查5条,默认25条) docker search --limit 5 镜像名称 #拉取镜像 :TAG表示所需要下载的版本 docker pull 镜像名称:TAG #查看docker镜像/容器/数据卷所占空间 docker system df #删除某个镜像 -f表示强制删除 docker rmi -f 镜像ID/镜像名称:TAG #删除多个镜像 docker rmi -f 镜像ID/镜像名称:TAG 镜像ID/镜像名称:TAG 镜像ID/镜像名称:TAG #删除全部镜像 docker rmi -f $(docker images -qa) #TODO代整理的面试题 什么是虚悬镜像? 仓库名、标签都是none的镜像,俗称虚悬镜像dangling image 3. 容器命令 #通过镜像启动一个容器 docker run [options] 镜像名称:TAG --name=\"容器名字\" 表示为当前容器指定名称 -d 后台运行容器并返回容器ID,即启动守护式容器 -i 以交互模式运行容器,通常与-t同时使用,例如docker操作ubuntu docker run -it ubuntu /bin/bash -t 为容器分配一个伪输入终端,通常与-i同时使用,即启动交互式容器(前台有伪终端等待交互) -p 指定端口映射 例如指定redis映射端口 -p 6979:6379 即表示外部访问6979最终是映射到了6379端口 -P 随机端口映射 #查看已启动的容器列表 docker ps -a -l -a 表示所有启动过的容器(包含已删除过的) -l 显示最近创建的容器 -n 显示最近n个创建的容器 例如 docker ps -n 2 -q 只显示容器id 组合使用案例 docker ps -aqn 2 #交互式容器退出/停止 exit ctrl+p+q 退出当前操作界面,容器后台运行 随之而来的问题既然退出去了那怎么回来 docker exec [options] 容器id/名称 /bin/bash -d 后台运行容器并返回容器ID,即启动守护式容器 docker exec -d 容器id/名称 /bin/bash -i 以交互模式运行容器,通常与-t同时使用,例如docker操作ubuntu docker run -it ubuntu /bin/bash -t 为容器分配一个伪输入终端,通常与-i同时使用,即启动交互式容器(前台有伪终端等待交互) docker exec -it 容器id/名称 /bin/bash docker attach 容器id/名称 #TODO面试题 attach与exec 的区别? attach直接进入容器启动命令的终端,不会启动新的进程,用exit退出，会导致容器的停止。 exec是在容器中打开新的终端,并且可以启动新的进程,用exit退出，不会导致容器的停止。(推荐使用) #启动已停止的容器 docker start 容器id/名称 #重启容器 docker restart 容器id/名称 #停止容器 docker stop 容器id/名称 #强制停止容器 docker kill 容器id/名称 #删除已停止的容器 docker rm 容器id/名称 #强制删除 docker rm -f 容器id/名称 #删除多个容器 docker rm -f(docker ps -a -q) 删除所有已启动过的容器根据容器id docker ps -a | xargs docker rm #查看容器日志 docker logs 容器id/名称 #查看容器内运行的进程 docker top 容器id/名称 #查看容器内部细节信息 docker inspect 容器id/名称 #从容器拷贝文件到主机 docker cp 容器id/名称:容器内路径 目的主机路径 docker cp ddblae9o9a66:/tmp/a.txt /usr/local/ss #导入/导出容器 docker export 容器ID/名称 > xxx.tar cat 文件名称 | docker import - 路径名称/容器名称:版本信息 cat redis-container.tar | docker import - dream/redis:6.0.8 4. commit命令 docker commit -m=\"此次提交的描述信息\" -a=\"作者信息\" 容器ID 目标镜像名称:TAG © Ale all right reserved，powered by Gitbook该文修订时间： 2022-05-20 11:20:04 "},"docker/docker-container.html":{"url":"docker/docker-container.html","title":"Docker容器数据卷","keywords":"","body":"Docker容器数据卷 1.容器数据卷是什么? 卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器， 但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性; 卷的设计目的就是数据的持久他，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷 2.容器数据卷的目的是什么? 运用与运行的环境打包镜像，run后形成容器实例运行，对于容器内产生的某些数据我们希望能够持久化，所以容器卷正是用于此(包括但不限于)。 Docker容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。 为了能保存数据在Docker中我们使用卷。 3.容器数据卷特点 1. 数据卷可在容器之间共享或重用数据 2. 卷中的更改可以直接实时生效 3. 数据卷中的更改不会包含在镜像的更新中 4. 数据卷的生命周期一直持续到没有容器使用它为止 4. 容器数据卷案例 4.1 宿主机与容器之间映射添加容器卷 #配置容器卷映射(如目录不存在会自动创建) docker run -it --privileged=true -v /宿主机绝对路径:/容器目录 镜像名称:TAG #查看容器卷挂载信息 docker inspect 容器ID PS:即使容器已经停止运行,宿主机在挂载目录中继续写入数据,容器重启后任能获取 4.2 容器卷读写规则 #添加容器卷映射规则 docker run -it --privileged=true -v /宿主机绝对路径:/容器目录:rw 镜像名称:TAG :rw 表示默认规则-可读可写 :ro 表示(read only)只读 4.3 容器卷的继承 docker run -it --privileged=true --volumes-from 容器名称 --name=xxx 镜像名称 © Ale all right reserved，powered by Gitbook该文修订时间： 2022-05-23 15:10:06 "},"docker/docker-pushaliyun.html":{"url":"docker/docker-pushaliyun.html","title":"Docker本地推送到阿里云","keywords":"","body":"docker 本地推送到阿里云 1.配置阿里云 1.1 登录阿里云 1.2 控制台中选择镜像服务 1.3 配置个人实例(没有则先创建) 1.4 创建命名空间 1.5 创建镜像仓库 2.阿里云镜像仓库操作指南 1. 登录阿里云Docker Registry - docker login --username=阿里云账号名称 registry.cn-hangzhou.aliyuncs.com - 用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。 2. 从Registry中拉取镜像 - docker pull registry.cn-hangzhou.aliyuncs.com/docker-repository-01/docker-dev1:[镜像版本号] 3. 将镜像推送到Registry - docker login --username=超人不会飞icu registry.cn-hangzhou.aliyuncs.com - docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/docker-repository-01/docker-dev1:[镜像版本号] - docker push registry.cn-hangzhou.aliyuncs.com/docker-repository-01/docker-dev1:[镜像版本号] © Ale all right reserved，powered by Gitbook该文修订时间： 2022-05-20 14:48:59 "},"docker/docker-private.html":{"url":"docker/docker-private.html","title":"Docker私有库","keywords":"","body":"Docker私有库配置 1. 下载registry docker pull registry 2. 运行私有库 docker run -d -p 5000:5000 -v /luyaoz/myregistry/:/tmp/registry --privileged=true registry 3. 推送镜像到私有库 #1查看私有库镜像列表 curl -XGET http://1.12.248.253:5000/v2/_catalog #2修改镜像信息 docker tag 镜像名称:TAG 服务器ip:私服库端口/镜像名称:TAG #3取消docker http限制 vim /etc/docker/daemon.json { \"registry-mirrors\": [\"https://aa25jngu.mirror.aliyuncs.com\"], //阿里镜像加速 \"insecure-registries\": [\"服务器ip:docker私有库端口\"] //取消docker HTTP限制 } #4推送本地镜像到私有库 docker push 镜像名称:TAG #5查看私有库镜像列表 curl -XGET http://1.12.248.253:5000/v2/_catalog #6拉取私有库镜像 docker pull 服务器ip:端口/镜像名称:TAG © Ale all right reserved，powered by Gitbook该文修订时间： 2022-05-21 16:27:07 "},"docker/docker-appinstall.html":{"url":"docker/docker-appinstall.html","title":"Docker安装常用软件","keywords":"","body":"Docker安装常用开发软件 1.Tomcat安装 1. 下载 - docker pull tomcat:TAG 2. 启动 - docker run -it -p 8080:8080 --name=xxx 镜像名称:标签 3. 注意 - 新版tomcat默认没有web应用(也就是那只猫的首页),所以访问会报404,若需要显示则可输入以下命令配置 - docker exec -it 容器ID/容器名称 /bin/bash 表示在运行的容器中执行命令 - rm -r webapps 删除空的webapps目录 - mv webapps.dist webapps 修改webapps.dist为webapps - 解释说明:webapps.dist中才是存在tomcat的启动页应用,但是在新版本中默认的是用的空的webapps # 免修改版基于tomcat8 - docker run -d -p 8080:8080 --name tomcat8 billygoo/tomcat8-jdk8 2.Mysql安装 #下载 docker pull mysql:TAG #启动 docker run -d -p 3306:3306 --privileged=true -v /luyaoz/mysql/log:/var/log/mysql -v /luyaoz/mysql/data:/var/lib/mysql -v /luyaoz/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root --name=mysql-dev mysql:TAG #配置mysql 1. 进入宿主机/luyaoz/mysql/conf目录下新建my.cnf cd /luyaoz/mysql/conf vim my.cnf 2. 在my.cnf新增配置 [client] default-character-set=utf8mb4 [mysqld] collation_server=utf8_general_ci character_set_server=utf8 #重启容器 docker restart 容器实例ID/容器实例名称 #进入容器 docker exec -it 容器实例名称/容器实例ID /bin/bash #登录mysql mysql -uroot -p #查看字符集 SHOW VARIABLES LIKE 'character%'; 3.Redis安装 #下载 docker pull redis:TAG #宿主机创建redis配置文件 1. mkdir /luyaoz/redis/redis.conf 2. 找份原生的redis.conf配置文件复制进宿主机的配置文件中 3. 进行相应配置(如配置有误会导致redis启动失败) #启动redis docker run -d -p 6379:6379 --privileged=true -v /luyaoz/redis/redis.conf:/etc/redis/redis.conf -v /luyaoz/redis/data:/data --name redis-dev redis:tag redis-server /etc/redis/redis.conf © Ale all right reserved，powered by Gitbook该文修订时间： 2022-05-25 15:27:55 "}}